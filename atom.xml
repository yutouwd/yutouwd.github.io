<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yutouwd</title>
  
  <subtitle>我的「精神家园」</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yutouwd.github.io/"/>
  <updated>2021-09-27T09:18:52.080Z</updated>
  <id>http://yutouwd.github.io/</id>
  
  <author>
    <name>yutouwd</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>解码方法 1 &amp; 2</title>
    <link href="http://yutouwd.github.io/posts/4143396234/"/>
    <id>http://yutouwd.github.io/posts/4143396234/</id>
    <published>2021-09-27T09:09:25.000Z</published>
    <updated>2021-09-27T09:18:52.080Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="解码方法1"><a href="#解码方法1" class="headerlink" title="解码方法1"></a>解码方法1</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/decode-ways/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/decode-ways/</a><br>一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：</p><p>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>‘Z’ -&gt; 26<br>要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，”11106” 可以映射为：</p><p>“AAJF” ，将消息分组为 (1 1 10 6)<br>“KJF” ，将消息分组为 (11 10 6)<br>注意，消息不能分组为  (1 11 06) ，因为 “06” 不能映射为 “F” ，这是由于 “6” 和 “06” 在映射中并不等价。</p><p>给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。<br>题目数据保证答案肯定是一个 32 位 的整数。</p><p>示例 1：<br>输入：s = “12”<br>输出：2<br>解释：它可以解码为 “AB”（1 2）或者 “L”（12）。</p><p>示例 2：<br>输入：s = “226”<br>输出：3<br>解释：它可以解码为 “BZ” (2 26), “VF” (22 6), 或者 “BBF” (2 2 6) 。</p><p>示例 3：<br>输入：s = “0”<br>输出：0<br>解释：没有字符映射到以 0 开头的数字。<br>含有 0 的有效映射是 ‘J’ -&gt; “10” 和 ‘T’-&gt; “20” 。<br>由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。</p><p>示例 4：<br>输入：s = “06”<br>输出：0<br>解释：”06” 不能映射到 “F” ，因为字符串含有前导 0（”6” 和 “06” 在映射中并不等价）。</p><p>提示：<br>1 &lt;= s.length &lt;= 100<br>s 只包含数字，并且可能包含前导零。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>一开始写了好多if else，结果总有通不过的用例。看了题解真的简洁明了，只需要考虑两种情况：第一种是只考虑当前字符；另外一种考虑当前字符和前面一个字符。其实有些像加上了一些判断条件的爬楼梯。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i<span class="number">-1</span>] != <span class="string">'0'</span>)</span><br><span class="line">                dp[i] += dp[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; s[i<span class="number">-2</span>] != <span class="string">'0'</span> &amp;&amp; (s[i<span class="number">-2</span>]-<span class="string">'0'</span>)*<span class="number">10</span> + (s[i<span class="number">-1</span>]-<span class="string">'0'</span>) &lt;= <span class="number">26</span>)</span><br><span class="line">                dp[i] += dp[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="解码方法2"><a href="#解码方法2" class="headerlink" title="解码方法2"></a>解码方法2</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/decode-ways-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/decode-ways-ii/</a><br>一条包含字母 A-Z 的消息通过以下的方式进行了编码：</p><p>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>‘Z’ -&gt; 26<br>要 解码 一条已编码的消息，所有的数字都必须分组，然后按原来的编码方案反向映射回字母（可能存在多种方式）。例如，”11106” 可以映射为：</p><p>“AAJF” 对应分组 (1 1 10 6)<br>“KJF” 对应分组 (11 10 6)<br>注意，像 (1 11 06) 这样的分组是无效的，因为 “06” 不可以映射为 ‘F’ ，因为 “6” 与 “06” 不同。</p><p>除了 上面描述的数字字母映射方案，编码消息中可能包含 ‘<em>‘ 字符，可以表示从 ‘1’ 到 ‘9’ 的任一数字（不包括 ‘0’）。例如，编码字符串 “1</em>“ 可以表示 “11”、”12”、”13”、”14”、”15”、”16”、”17”、”18” 或 “19” 中的任意一条消息。对 “1*” 进行解码，相当于解码该字符串可以表示的任何编码消息。</p><p>给你一个字符串 s ，由数字和 ‘*’ 字符组成，返回 解码 该字符串的方法 数目 。</p><p>由于答案数目可能非常大，返回对 109 + 7 取余 的结果。</p><p>示例 1：<br>输入：s = “<em>“<br>输出：9<br>解释：这一条编码消息可以表示 “1”、”2”、”3”、”4”、”5”、”6”、”7”、”8” 或 “9” 中的任意一条。<br>可以分别解码成字符串 “A”、”B”、”C”、”D”、”E”、”F”、”G”、”H” 和 “I” 。<br>因此，”</em>“ 总共有 9 种解码方法。</p><p>示例 2：<br>输入：s = “1<em>“<br>输出：18<br>解释：这一条编码消息可以表示 “11”、”12”、”13”、”14”、”15”、”16”、”17”、”18” 或 “19” 中的任意一条。<br>每种消息都可以由 2 种方法解码（例如，”11” 可以解码成 “AA” 或 “K”）。<br>因此，”1</em>“ 共有 9 * 2 = 18 种解码方法。</p><p>示例 3：<br>输入：s = “2<em>“<br>输出：15<br>解释：这一条编码消息可以表示 “21”、”22”、”23”、”24”、”25”、”26”、”27”、”28” 或 “29” 中的任意一条。<br>“21”、”22”、”23”、”24”、”25” 和 “26” 由 2 种解码方法，但 “27”、”28” 和 “29” 仅有 1 种解码方法。<br>因此，”2</em>“ 共有 (6 <em> 2) + (3 </em> 1) = 12 + 3 = 15 种解码方法。</p><p>提示：<br>1 &lt;= s.length &lt;= 105<br>s[i] 是 0 - 9 中的一位数字或字符 ‘*’</p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>这题有更多的情况，不过大致思路还是和解码方法1一样，考虑一个字符和两个字符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> check1digit = [](<span class="keyword">char</span> c) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'0'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> c == <span class="string">'*'</span> ? <span class="number">9</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> check2digit = [](<span class="keyword">char</span> c0, <span class="keyword">char</span> c1) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (c0 == <span class="string">'*'</span> &amp;&amp; c1 == <span class="string">'*'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">15</span>;</span><br><span class="line">            <span class="keyword">if</span> (c0 == <span class="string">'*'</span>)</span><br><span class="line">                <span class="keyword">return</span> c1 &lt;= <span class="string">'6'</span> ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (c1 == <span class="string">'*'</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> c0 == <span class="string">'1'</span> ? <span class="number">9</span> : c0 == <span class="string">'2'</span> ? <span class="number">6</span> : <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c0 != <span class="string">'0'</span> &amp;&amp; (c0 - <span class="string">'0'</span>) * <span class="number">10</span> + (c1 - <span class="string">'0'</span>) &lt;= <span class="number">26</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pre2 = <span class="number">0</span>, pre1 = <span class="number">1</span>, curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n ; i++)&#123;</span><br><span class="line">            curr = (<span class="keyword">long</span> <span class="keyword">long</span>)pre1 * check1digit(s[i<span class="number">-1</span>]) % mod;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">1</span>)</span><br><span class="line">                curr = (curr + (<span class="keyword">long</span> <span class="keyword">long</span>)pre2 * check2digit(s[i<span class="number">-2</span>],s[i<span class="number">-1</span>])) % mod;</span><br><span class="line">            pre2 = pre1;</span><br><span class="line">            pre1 = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="leetcode" scheme="http://yutouwd.github.io/categories/leetcode/"/>
    
      <category term="hard" scheme="http://yutouwd.github.io/categories/leetcode/hard/"/>
    
    
      <category term="leetcode" scheme="http://yutouwd.github.io/tags/leetcode/"/>
    
      <category term="string" scheme="http://yutouwd.github.io/tags/string/"/>
    
      <category term="动态规划" scheme="http://yutouwd.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="lambda表达式" scheme="http://yutouwd.github.io/tags/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>725.Split LinkedList in Parts</title>
    <link href="http://yutouwd.github.io/posts/3339355851/"/>
    <id>http://yutouwd.github.io/posts/3339355851/</id>
    <published>2021-09-22T07:59:56.000Z</published>
    <updated>2021-09-22T08:05:54.258Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个头结点为 head 的单链表和一个整数 k ，请你设计一个算法将链表分隔为 k 个连续的部分。<br>每部分的长度应该尽可能的相等：任意两部分的长度差距不能超过 1 。这可能会导致有些部分为 null 。<br>这 k 个部分应该按照在链表中出现的顺序排列，并且排在前面的部分的长度应该大于或等于排在后面的长度。<br>返回一个由上述 k 部分组成的数组。</p><p>示例 1：<br>输入：head = [1,2,3], k = 5<br>输出：[[1],[2],[3],[],[]]<br>解释：<br>第一个元素 output[0] 为 output[0].val = 1 ，output[0].next = null 。<br>最后一个元素 output[4] 为 null ，但它作为 ListNode 的字符串表示是 [] 。</p><p>示例 2：<br>输入：head = [1,2,3,4,5,6,7,8,9,10], k = 3<br>输出：[[1,2,3,4],[5,6,7],[8,9,10]]<br>解释：<br>输入被分成了几个连续的部分，并且每部分的长度相差不超过 1 。前面部分的长度大于等于后面部分的长度。</p><p>提示：</p><p>链表中节点的数目在范围 [0, 1000]<br>0 &lt;= Node.val &lt;= 1000<br>1 &lt;= k &lt;= 50</p><h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>一开始想着分成len小于等于k和大于k两种情况，但是看题解发现，其实并不需要分成这两种情况。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;ListNode*&gt; <span class="title">splitListToParts</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;ListNode*&gt; res;</span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= k)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">                ListNode* tmp = p -&gt; next;</span><br><span class="line">                p -&gt; next = <span class="literal">nullptr</span>;</span><br><span class="line">                res.push_back(p);</span><br><span class="line">                p = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k-len; i++)</span><br><span class="line">                res.push_back(<span class="literal">nullptr</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> div = len / k, mod = len % k;</span><br><span class="line">            <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">                ListNode* t = p;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; div<span class="number">-1</span>; j++)</span><br><span class="line">                    t = t -&gt; next;</span><br><span class="line">                <span class="keyword">if</span> (n &lt; mod)&#123;</span><br><span class="line">                    n++;</span><br><span class="line">                    t = t -&gt; next;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode* tmp = t -&gt; next;</span><br><span class="line">                t -&gt; next = <span class="literal">nullptr</span>;</span><br><span class="line">                res.push_back(p);</span><br><span class="line">                p = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="高票解法"><a href="#高票解法" class="headerlink" title="高票解法"></a>高票解法</h1><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h2><p>题解写得还是简洁多了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;ListNode*&gt; <span class="title">splitListToParts</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        ListNode *temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            n++;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> quotient = n / k, remainder = n % k;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;ListNode*&gt; <span class="title">parts</span><span class="params">(k,<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">        ListNode *curr = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k &amp;&amp; curr != <span class="literal">nullptr</span>; i++) &#123;</span><br><span class="line">            parts[i] = curr;</span><br><span class="line">            <span class="keyword">int</span> partSize = quotient + (i &lt; remainder ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; partSize; j++) &#123;</span><br><span class="line">                curr = curr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode *next = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parts;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="leetcode" scheme="http://yutouwd.github.io/categories/leetcode/"/>
    
      <category term="medium" scheme="http://yutouwd.github.io/categories/leetcode/medium/"/>
    
    
      <category term="leetcode" scheme="http://yutouwd.github.io/tags/leetcode/"/>
    
      <category term="list" scheme="http://yutouwd.github.io/tags/list/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法-前缀树</title>
    <link href="http://yutouwd.github.io/posts/3444422637/"/>
    <id>http://yutouwd.github.io/posts/3444422637/</id>
    <published>2021-09-16T06:16:50.000Z</published>
    <updated>2021-09-27T08:51:47.328Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>做每日一题看到题解需要用到前缀树，之前完全没听说过。于是就打算好好学习一下。</p><h1 id="前缀树定义"><a href="#前缀树定义" class="headerlink" title="前缀树定义"></a>前缀树定义</h1><p>Leetcode <a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">#208</a></p><p>Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p><p>请你实现 Trie 类：<br>Trie() 初始化前缀树对象。<br>void insert(String word) 向前缀树中插入字符串 word 。<br>boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。<br>boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。</p><h1 id="前缀树实现"><a href="#前缀树实现" class="headerlink" title="前缀树实现"></a>前缀树实现</h1><p>不看题解真的不太能理解前缀树到底干了啥，但是看了题解之后就发现前缀树也挺简单的。它可以理解成为一个26叉树，每一个叉对应一个字符。并且每个节点要记录是不是结尾，来判断当前路径能不能构成一个字符串（一个节点可以是结尾，也可以继续指向下一个Trie）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> isEnd;</span><br><span class="line">    Trie* next[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    Trie() &#123;</span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">memset</span>(next, <span class="number">0</span>, <span class="keyword">sizeof</span>(next)); <span class="comment">// 将next数组初始化为0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : word)&#123;</span><br><span class="line">            <span class="keyword">if</span> (node -&gt; next[c - <span class="string">'a'</span>] == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                node -&gt; next[c - <span class="string">'a'</span>] = <span class="keyword">new</span> Trie();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node -&gt; next[c - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        node -&gt; isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : word)&#123;</span><br><span class="line">            node = node -&gt; next[c - <span class="string">'a'</span>];</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node -&gt; isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : prefix)&#123;</span><br><span class="line">            node = node -&gt; next[c - <span class="string">'a'</span>];</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在官方题解评论中看到一个更好的版本。因为search和startWith前面其实做的事情差不多，所以可以写一个searchPrefix函数来搜索前缀，简化下代码。并且可以用一个数组来记录new生成的node，最后在析构的时候delete掉。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> isEnd;</span><br><span class="line">    Node* children[<span class="number">26</span>];</span><br><span class="line">    Node():isEnd(<span class="literal">false</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(children,<span class="number">0</span>,<span class="keyword">sizeof</span> children);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node*&gt;pool;</span><br><span class="line">    <span class="function">Node* <span class="title">searchPrefix</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</span><br><span class="line">        Node* node = pool[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : prefix) &#123;</span><br><span class="line">            ch -= <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[ch] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[ch];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Trie() : pool(<span class="number">1</span>) &#123;</span><br><span class="line">        pool[<span class="number">0</span>] = <span class="keyword">new</span> Node;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Trie()&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp;t:pool)&#123;</span><br><span class="line">            <span class="keyword">delete</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//每次入新的表需要把它们加入到内存池，方便最后析构函数的清理</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        Node* node = pool[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : word) &#123;</span><br><span class="line">            ch -= <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[ch] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                node-&gt;children[ch] = <span class="keyword">new</span> Node;</span><br><span class="line">                pool.emplace_back(node-&gt;children[ch]);</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[ch];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        Node* node = <span class="keyword">this</span>-&gt;searchPrefix(word);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">nullptr</span> &amp;&amp; node-&gt;isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;searchPrefix(prefix) != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="前缀树应用"><a href="#前缀树应用" class="headerlink" title="前缀树应用"></a>前缀树应用</h1><h2 id="单词的压缩编码"><a href="#单词的压缩编码" class="headerlink" title="单词的压缩编码"></a>单词的压缩编码</h2><p>Leetcode <a href="https://leetcode-cn.com/problems/short-encoding-of-words/" target="_blank" rel="noopener">#820</a></p><p>单词数组 words 的 有效编码 由任意助记字符串 s 和下标数组 indices 组成，且满足：<br>words.length == indices.length<br>助记字符串 s 以 ‘#’ 字符结尾<br>对于每个下标 indices[i] ，s 的一个从 indices[i] 开始、到下一个 ‘#’ 字符结束（但不包括 ‘#’）的 子字符串 恰好与 words[i] 相等<br>给你一个单词数组 words ，返回成功对 words 进行编码的最小助记字符串 s 的长度 。</p><p>示例 1：</p><p>输入：words = [“time”, “me”, “bell”]<br>输出：10<br>解释：一组有效编码为 s = “time#bell#” 和 indices = [0, 2, 5] 。<br>words[0] = “time” ，s 开始于 indices[0] = 0 到下一个 ‘#’ 结束的子字符串，如加粗部分所示 “time#bell#”<br>words<a href="https://leetcode-cn.com/problems/short-encoding-of-words/" target="_blank" rel="noopener">1</a> = “me” ，s 开始于 indices<a href="https://leetcode-cn.com/problems/short-encoding-of-words/" target="_blank" rel="noopener">1</a> = 2 到下一个 ‘#’ 结束的子字符串，如加粗部分所示 “time#bell#”<br>words<a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">2</a> = “bell” ，s 开始于 indices<a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">2</a> = 5 到下一个 ‘#’ 结束的子字符串，如加粗部分所示 “time#bell#”</p><p>示例 2：<br>输入：words = [“t”]<br>输出：2<br>解释：一组有效编码为 s = “t#” 和 indices = [0] 。</p><p>提示：<br>1 &lt;= words.length &lt;= 2000<br>1 &lt;= words[i].length &lt;= 7<br>words[i] 仅由小写字母组成</p><p>这题可以用前缀树来做，不过要把单词反转过来，并且要将单词从长到短排序加入到前缀树中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Trie* next[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Trie()&#123;</span><br><span class="line">        <span class="built_in">memset</span>(next, <span class="number">0</span>, <span class="keyword">sizeof</span>(next));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> word)</span></span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : word)&#123;</span><br><span class="line">            c -= <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (node -&gt; next[c] == <span class="literal">NULL</span>) node -&gt; next[c] = <span class="keyword">new</span> Trie();</span><br><span class="line">            node = node -&gt; next[c];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startWith</span><span class="params">(<span class="built_in">string</span> word)</span></span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : word)&#123;</span><br><span class="line">            c -= <span class="string">'a'</span>;</span><br><span class="line">            node = node -&gt; next[c];</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cmp=[&amp;](<span class="built_in">string</span> &amp;a, <span class="built_in">string</span> &amp;b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a.size() &gt; b.size();</span><br><span class="line">        &#125;;</span><br><span class="line">        sort(words.begin(), words.end(), cmp);</span><br><span class="line">        Trie root;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span> s : words)&#123;</span><br><span class="line">            <span class="function"><span class="built_in">string</span> <span class="title">r</span><span class="params">(s)</span></span>;</span><br><span class="line">            reverse(r.begin(),r.end());</span><br><span class="line">            <span class="keyword">if</span> (root.startWith(r)) <span class="keyword">continue</span>;</span><br><span class="line">            root.insert(r);</span><br><span class="line">            res += r.size() + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>前缀树介绍和实现：<br><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/trie-tree-de-shi-xian-gua-he-chu-xue-zhe-by-huwt/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/trie-tree-de-shi-xian-gua-he-chu-xue-zhe-by-huwt/</a><br><a href="https://blog.csdn.net/m0_46202073/article/details/107253959" target="_blank" rel="noopener">https://blog.csdn.net/m0_46202073/article/details/107253959</a><br>Merkle Patricia Tree:<br><a href="https://ethfans.org/toya/articles/588" target="_blank" rel="noopener">https://ethfans.org/toya/articles/588</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="leetcode" scheme="http://yutouwd.github.io/categories/leetcode/"/>
    
      <category term="数据结构总结" scheme="http://yutouwd.github.io/categories/leetcode/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="leetcode" scheme="http://yutouwd.github.io/tags/leetcode/"/>
    
      <category term="string" scheme="http://yutouwd.github.io/tags/string/"/>
    
      <category term="lambda表达式" scheme="http://yutouwd.github.io/tags/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="前缀树" scheme="http://yutouwd.github.io/tags/%E5%89%8D%E7%BC%80%E6%A0%91/"/>
    
      <category term="trees" scheme="http://yutouwd.github.io/tags/trees/"/>
    
  </entry>
  
  <entry>
    <title>Probability - Sample Space and Probability</title>
    <link href="http://yutouwd.github.io/posts/457064921/"/>
    <id>http://yutouwd.github.io/posts/457064921/</id>
    <published>2021-09-14T15:00:09.000Z</published>
    <updated>2021-09-28T03:09:04.175Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="采样空间"><a href="#采样空间" class="headerlink" title="采样空间"></a>采样空间</h1><ul><li>“List” (set) of possible outcomes. List must be mutually exclusive (互斥的) and collectively exhaustive (穷尽的)</li><li>采样空间可以分为离散空间和连续空间。</li></ul><h1 id="概率论中的公理"><a href="#概率论中的公理" class="headerlink" title="概率论中的公理"></a>概率论中的公理</h1><p>两个定义</p><ul><li>事件：是采样空间的一个子集</li><li>每个事件都会有对应的概率</li></ul><p>三个公理:</p><ul><li>Nonnegativity 非负性：$\rm P(A)\ge0$</li><li>Normalization 归一化：$\rm P(\Omega)=1$ 指的是整个采样空间的概率为1</li><li>Additivity 互斥事件的加法法则：如果A和B两个事件互斥，即$A\cap B=\varnothing$，那么$\rm P(A\cup B)=P(A)+P(B)$</li></ul><p>公理3可以推广到多个互斥事件上。</p><h1 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h1><p>定义：$\rm P(A|B)=$当B发生，A发生的概率<br>当$\rm P(B)\neq 0$，有：</p><p>\begin{equation}<br>\rm<br>P(A|B)=\frac{\rm P(A\cap B)}{\rm P(B)}<br>\end{equation}</p><p>根据条件概率可以推导出：<br>\begin{equation}<br>\rm<br>P(A\cap B)=P(B)P(A|B)<br>\end{equation}<br>再结合公理3可以推出：<br>\begin{equation}<br>\rm<br>P(A\cup B|C)=P(A|C)+P(B|C)<br>\end{equation}<br>乘法法则：<br>\begin{equation}\begin{split}\rm P(A\cap B \cap C)&amp;=\rm P(A\cap B)P(C|A\cap B)\\<br>&amp;=\rm P(A)P(B|A)P(C|A\cap B)<br>\end{split}\end{equation}</p><h1 id="全概率公式"><a href="#全概率公式" class="headerlink" title="全概率公式"></a>全概率公式</h1><p>假设采样空间可以分成${A_1,A_2,…,A_n}$</p><p>\begin{equation}<br>\begin{split}<br>\rm<br>P(B)&amp;=\sum_{i=1}^{n}P(B\cap A_i)\\<br>&amp;=\sum_{i=1}^{n}P(A_i)P(B|A_i)<br>\end{split}<br>\end{equation}</p><h1 id="贝叶斯公式"><a href="#贝叶斯公式" class="headerlink" title="贝叶斯公式"></a>贝叶斯公式</h1><p>已知先验概率$P(A_i)$和$P(B|A_i)$，求$P(A_i|B)$。</p><p>\begin{equation}<br>\begin{split}<br>\rm<br>P(A_i|B)&amp;=\frac{\rm P(A_i\cap B)}{\rm P(B)}\\<br>&amp;=\frac{\rm P(A_i)P(B|A_i)}{\rm \sum_{j=1}^{n}P(A_j)P(B|A_j)}<br>\end{split}<br>\end{equation}</p><h1 id="独立事件"><a href="#独立事件" class="headerlink" title="独立事件"></a>独立事件</h1><p>定义：两个事件是独立的，指一次实验中一事件的发生不会影响到另一事件发生的概率。如果$P(B|A)=P(B)$或者$P(A\cap B)=P(A)P(B)$，就可以称A与B是互相独立的事件。</p><p>“条件”可能会影响两个事件的独立性：Independency in original model does not imply independency in the conditional model. 反之也成立。</p><h1 id="组合-Combinations"><a href="#组合-Combinations" class="headerlink" title="组合 Combinations"></a>组合 Combinations</h1><p>这里组合表示为<br>\begin{equation}<br>\rm<br>(^n_k)=\frac{\rm n!}{\rm k!(n-k)!}<br>\end{equation}<br>打出来有些难看，又不想打大括号复杂的公式，后面还是用$C_n^k$来表示吧。</p><h1 id="Assignment"><a href="#Assignment" class="headerlink" title="Assignment"></a>Assignment</h1><h2 id="Problem-Set-1"><a href="#Problem-Set-1" class="headerlink" title="Problem Set 1"></a>Problem Set 1</h2><img src="/posts/457064921/ProblemSet1-1.png"><p>1:<br>(a) $\rm A\cup B\cup C$<br>(b) $\rm (A\cap B^c\cap C^c)\cup (A^c\cap B\cap C^c)\cup (A^c\cap B^c\cap C)\cup (A^c\cap B^c\cap C^c)$<br>(c) $\rm (A\cup B\cup C)^c$<br>(d) $\rm A\cap B\cap C$<br>(e) $\rm (A\cap B^c\cap C^c)\cup (A^c\cap B\cap C^c)\cup (A^c\cap B^c\cap C)$<br>(f) $\rm A\cap B\cap C^c$<br>(g) $\rm A\cup B^c$<br>这里(g)做错了，应该是$A\cup (A^c\cap B^c)$。因为题目是A发生，或者当A不发生时，B也不发生。</p><p>2:<br>(a) 1/8<br>(b) 1/8<br>(c) 3/8<br>(d) 1/2</p><p>3:<br>这题目是真的没看懂😅，看了下答案才知道大概意思。就是两个骰子摇出来的结果的和是和所有结果的总和成比例的。需要把全部可能结果列出来然后算出概率。</p><p>4:<br>P(B)=71/72<br>P(C)=0<br>$P(A\cap D)=25/72$</p><p>这里只有P(C)做对了。P(B)的面积应该是一个小正方形而不是三角形，这里想错了，所以应该是35/36。$P(A\cap D)$这里算少了上面一部分，只计算了Alice大于1/3并且大于Bob 1/3的部分，没有算上小于Bob的部分，最终结果应该是41/72。</p><img src="/posts/457064921/ProblemSet1-2.png"><p>5:<br>(a) 圆的面积是半径平方乘以$\pi$，要等50分就要在1in里面，所以应该是1/100。<br>(b)30分是在1～3in这个空心圆中(9-1)/100=2/25<br>(c)对John来说，结果和Mike应该是一样的，因为左右半区并不会影响成绩。</p><p>6:<br>这个真的想不到证明的方法。可以参考<a href="https://math.stackexchange.com/questions/2622714/prove-that-for-any-three-events-a-b-c-pabc-ge-pa-pb-pc-%E2%88%92-2" target="_blank" rel="noopener">https://math.stackexchange.com/questions/2622714/prove-that-for-any-three-events-a-b-c-pabc-ge-pa-pb-pc-%E2%88%92-2</a></p><h2 id="Problem-Set-2"><a href="#Problem-Set-2" class="headerlink" title="Problem Set 2"></a>Problem Set 2</h2><p>上课的时候感觉学的东西很简单，但是每次课后题都这么难。</p><img src="/posts/457064921/ProblemSet2-1.png"><p>1:<br>(a)<br>A = {Forecast is rain}<br>B = {It is rain}<br>C = {It is winter}<br>D = {It is summer}<br>\begin{equation}<br>\begin{split}<br>\rm<br>P(A|B\cup C)&amp;=\frac{\rm P(A\cup B\cup C)}{\rm P(B\cup C)}=\frac{56}{59}<br>\end{split}<br>\end{equation}</p><p>\begin{equation}<br>\begin{split}<br>\rm<br>P(A|B\cup D)&amp;=\frac{\rm P(A\cup B\cup D)}{\rm P(B\cup D)}=\frac{16}{24}<br>\end{split}<br>\end{equation}</p><p>(b)</p><p>2:<br>(a)<br>\begin{equation}<br>\rm<br>P(A) = \frac{1}{25} \\<br>P(B) = 1-\frac{16}{25}=\frac{9}{25} \\<br>P(C) = \frac{9}{25} \\<br>P(B|A)=1\neq P(B)<br>P(C|A)=0\neq P(C)<br>\end{equation}<br>所以，A与B或C都不独立。</p><p>(b)<br>\begin{equation}<br>\rm<br>P(D) = \frac{4}{25}\\<br>P(E) = \frac{8}{25}\\<br>P(F) = \frac{10}{25}\\<br>P(F|E) = \frac{1}{2} \neq P(F)<br>P(E|D) = \frac{1}{2}<br>P(F|D) = \frac{1}{2}<br>P(E\cap F |D)=\frac{1}{4}=P(E|D)P(F|D)<br>\end{equation}<br>(i) 因为$P(F|E)\neq P(F)$，所以他们是相关的<br>(ii) 但是在D发生的条件下，他们是无关的。</p><p>3:<br>(a)<br>\begin{equation}<br>\rm<br>P = \frac{1}{2}*0.15^2+\frac{1}{2}*0.05^2<br>\end{equation}<br>看了下答案，发现这里其实是一个没有放回的抽取，所以不能直接用平方。<br>(b)<br>\begin{equation}<br>\begin{split}<br>\rm<br>P(old|two\ defective)&amp;=\frac{\rm P(old)P(two\ defective)*P(old)}{\rm P(old)P(two\ defective|old)+P(new)P(two\ defective|new)}<br>\end{split}<br>\end{equation}</p><img src="/posts/457064921/ProblemSet2-2.png"><p>4:<br>(a)<br>$\rm P(A)=0.4,\ P(B)=0.6,\ P(find|A)=0.25,\ P(find|B)=0.15$<br>$\rm P(A\cap find)=P(find|A)P(A)=0.1$<br>$\rm P(B\cap find)=P(find|B)P(B)=0.09$<br>所以第一天应该选A森林<br>(b)<br>\begin{equation}<br>\begin{split}<br>\rm<br>P(A|not\ find\ in\ A)<br>&amp;=\rm \frac{\rm P(not\ find\ in\ A|A)P(A)}{\rm P(not\ find\ in\ A)}\\<br>&amp;=\rm \frac{\rm P(not\ find\ in\ A|A)P(A)}{\rm P(not\ find\ in\ A|A)P(A)+P(not\ find\ in\ A|B)P(B)}\\<br>&amp;=\rm \frac{\rm 0.75*0.4}{0.75*0.4+1*0.6}=\frac{1}{3}<br>\end{split}<br>\end{equation}<br>(c)<br>\begin{equation}<br>\begin{split}<br>\rm P(looked\ in\ A|find\ dog)&amp;=<br>\end{split}<br>\end{equation}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="数学" scheme="http://yutouwd.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="概率论" scheme="http://yutouwd.github.io/categories/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
    
      <category term="数学笔记" scheme="http://yutouwd.github.io/tags/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="概率论" scheme="http://yutouwd.github.io/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法-二分查找</title>
    <link href="http://yutouwd.github.io/posts/1125352499/"/>
    <id>http://yutouwd.github.io/posts/1125352499/</id>
    <published>2021-09-13T08:07:04.000Z</published>
    <updated>2021-09-23T08:32:27.402Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>前段时间做了几道二分查找的题目，总是不知道对于不同的情况，判定条件要怎么设置。所以就查查资料总结一下。</p><h1 id="二分查找思路"><a href="#二分查找思路" class="headerlink" title="二分查找思路"></a>二分查找思路</h1><p>这里主要是基于<a href="https://labuladong.gitbook.io/algo/mu-lu-ye/er-fen-cha-zhao-xiang-jie" target="_blank" rel="noopener">https://labuladong.gitbook.io/algo/mu-lu-ye/er-fen-cha-zhao-xiang-jie</a>的知识再总结。</p><p>二分查找是对于一个排序好的数组，找到符合条件的数字位置，比如某一个特定的数，或者找一个数开始和结束的位置。它的模版如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = ...;</span><br><span class="line">    <span class="keyword">while</span>(...)&#123;</span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的就是省略号的位置，需要真的不同情况进行修改。</p><h2 id="找到特定的数"><a href="#找到特定的数" class="headerlink" title="找到特定的数"></a>找到特定的数</h2><p>首先最简单的情况，就是在有序数组中找到特定的数<a href="https://yutouwd.github.io/posts/1944760669/">#704</a>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的条件都笔记符合直觉，我们在[0,nums.size()]中的区间搜索目标数，如果中间的数就是目标数的时候那么就返回索引；如果中间数小于目标数，那么目标数就会在[mid+1,right]这个范围内；如果中间数大于目标数，那么它会在[left,mid-1]这个范围内。最后，因为搜索区间两边都是[]，所以当left&gt;right的时候就代表全部搜索完了，那么while里的条件就是<code>left &lt;= right</code>。</p><p>搜索区间主要是由right初始化的值所决定的，当<code>right=nums.size()-1</code>，那么搜索区间是一个闭合区间，因为<code>nums.size()-1</code>是数组的一个有效的索引。如果<code>right=nums.size()</code>的话，搜索区间就变成半闭半开的了[0,nums.size())。</p><h2 id="找到特定数的左边界"><a href="#找到特定数的左边界" class="headerlink" title="找到特定数的左边界"></a>找到特定数的左边界</h2><p>搜索区间还是[0,nums.size()]，找到特定数多左边界，我们就需要修改if后面的条件了。首先是等于，等于的时候我们希望继续再往左边搜索，所以要从直接返回mid改成right=mid-1；然后是小于，小于的时候继续往右搜索，left=mid+1；大于的时候和等于一样，继续往左right=mid-1。这里需要注意的是最后返回值的处理，因为有可能target比数组中全部数都要大，需要处理一下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= nums.size() || nums[left] != target)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="找到特定数的右边界"><a href="#找到特定数的右边界" class="headerlink" title="找到特定数的右边界"></a>找到特定数的右边界</h2><p>有了左边界，右边界就不难了。只需要改一下等于时的条件和越界的条件就可以了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; <span class="number">0</span> || nums[right] != target)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="二分搜索应用"><a href="#二分搜索应用" class="headerlink" title="二分搜索应用"></a>二分搜索应用</h1><h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34.在排序数组中查找元素的第一个和最后一个位置"></a>34.在排序数组中查找元素的第一个和最后一个位置</h2><p>leetcode第<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34</a>题，找到左右边界。用两个函数实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binarySearchL</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= nums.size() || nums[left] != target)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binarySearchR</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; <span class="number">0</span> || nums[right] != target)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = binarySearchL(nums,target);</span><br><span class="line">        <span class="keyword">int</span> r = binarySearchR(nums,target);</span><br><span class="line">        <span class="keyword">return</span> &#123;l,r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="74-搜索二维矩阵"><a href="#74-搜索二维矩阵" class="headerlink" title="74.搜索二维矩阵"></a>74.搜索二维矩阵</h2><p>在二维矩阵中找有没有目标值，可以用两次二分查找。注意在第一次二分查找的时候，在小于的时候要记录下当前行。复杂度为O(log(mn))</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size(), m = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> rl = <span class="number">0</span>, rr = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (rl &lt;= rr)&#123;</span><br><span class="line">            <span class="keyword">int</span> rm = rl + (rr - rl) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (matrix[rm][<span class="number">0</span>] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[rm][<span class="number">0</span>] &gt; target)</span><br><span class="line">                rr = rm - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[rm][<span class="number">0</span>] &lt; target)&#123;</span><br><span class="line">                row = rm;</span><br><span class="line">                rl = rm + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cl = <span class="number">0</span>, cr = m<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (cl &lt;= cr)&#123;</span><br><span class="line">            <span class="keyword">int</span> cm = cl + (cr - cl) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (matrix[row][cm] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[row][cm] &gt; target)</span><br><span class="line">                cr = cm - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[row][cm] &lt; target)</span><br><span class="line">                cl = cm + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也可以将矩阵“展开”，用一次二分查找，复杂度为O(log(mn))。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size(), m = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = m * n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> i = mid / m, j = mid % m;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] &lt; target)</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] &gt; target)</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://labuladong.gitbook.io/algo/mu-lu-ye/er-fen-cha-zhao-xiang-jie" target="_blank" rel="noopener">https://labuladong.gitbook.io/algo/mu-lu-ye/er-fen-cha-zhao-xiang-jie</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="leetcode" scheme="http://yutouwd.github.io/categories/leetcode/"/>
    
      <category term="算法总结" scheme="http://yutouwd.github.io/categories/leetcode/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="leetcode" scheme="http://yutouwd.github.io/tags/leetcode/"/>
    
      <category term="二分查找" scheme="http://yutouwd.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
      <category term="数据结构与算法" scheme="http://yutouwd.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>1109.Corporate Flight Bookings</title>
    <link href="http://yutouwd.github.io/posts/2212932647/"/>
    <id>http://yutouwd.github.io/posts/2212932647/</id>
    <published>2021-08-31T03:10:46.000Z</published>
    <updated>2021-09-15T16:06:30.103Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>这里有 n 个航班，它们分别从 1 到 n 进行编号。</p><p>有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] = [firsti, lasti, seatsi] 意味着在从 firsti到 lasti （包含 firsti 和 lasti ）的 每个航班 上预订了 seatsi 个座位。<br>请你返回一个长度为 n 的数组 answer，其中 answer[i] 是航班 i 上预订的座位总数。</p><p>示例 1：<br>输入：bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5<br>输出：[10,55,45,25,25]<br>解释：<br>航班编号        1   2   3   4   5<br>预订记录 1 ：   10  10<br>预订记录 2 ：       20  20<br>预订记录 3 ：       25  25  25  25<br>总座位数：      10  55  45  25  25<br>因此，answer = [10,55,45,25,25]</p><p>示例 2：<br>输入：bookings = [[1,2,10],[2,2,15]], n = 2<br>输出：[10,25]<br>解释：<br>航班编号        1   2<br>预订记录 1 ：   10  10<br>预订记录 2 ：       15<br>总座位数：      10  25<br>因此，answer = [10,25]</p><p>提示：<br>1 &lt;= n &lt;= 2 <em> 104<br>1 &lt;= bookings.length &lt;= 2 </em> 104<br>bookings[i].length == 3<br>1 &lt;= firsti &lt;= lasti &lt;= n<br>1 &lt;= seatsi &lt;= 104</p><h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>看了题目感觉还挺简单的，结果直接用暴力法居然超时了。看了下题解才知道有差分数组这种东西，用来记录当前位置和上一个位置的差，就不需要全部一遍遍加上去了。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">corpFlightBookings</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; bookings, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = bookings.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            res[bookings[i][<span class="number">0</span>]<span class="number">-1</span>] += bookings[i][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (bookings[i][<span class="number">1</span>] &lt; n) <span class="comment">// 注意这里最后一位是不用处理的</span></span><br><span class="line">                res[bookings[i][<span class="number">1</span>]] -= bookings[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            res[i] += res[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="leetcode" scheme="http://yutouwd.github.io/categories/leetcode/"/>
    
      <category term="medium" scheme="http://yutouwd.github.io/categories/leetcode/medium/"/>
    
    
      <category term="leetcode" scheme="http://yutouwd.github.io/tags/leetcode/"/>
    
      <category term="vector" scheme="http://yutouwd.github.io/tags/vector/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法-排序算法</title>
    <link href="http://yutouwd.github.io/posts/3634812730/"/>
    <id>http://yutouwd.github.io/posts/3634812730/</id>
    <published>2021-08-23T08:52:36.000Z</published>
    <updated>2021-09-13T07:56:54.798Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>面试的时候总是会问到一些排序算法相关的问题，之前都只是囫囵吞枣的看了一下，被问的时候根本打不出来什么。所以还是要好好学习一下常用的几种排序算法，写一下学习笔记。</p><h1 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h1><p>这里参考：<a href="https://www.jianshu.com/p/334df02eb10a" target="_blank" rel="noopener">https://www.jianshu.com/p/334df02eb10a</a></p><p>首先需要一个生成随机数组的函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">generateRandomVector</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> rangeL, <span class="keyword">int</span> rangeR)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(rangeL &lt;= rangeR);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vec</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        vec[i] = rand() % (rangeR - rangeL + <span class="number">1</span>) + rangeL;</span><br><span class="line">    <span class="keyword">return</span> vec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以及一个判断数组是否排序好的函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSorted</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = vec.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (vec[i] &gt; vec[i+<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试排序函数能否正确排序以及返回所用时间。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">testSort</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; sortName, <span class="keyword">void</span>(*sortFunc)(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec)</span></span>&#123;</span><br><span class="line">    <span class="keyword">clock_t</span> startTime = clock();</span><br><span class="line">    sortFunc(vec);</span><br><span class="line">    <span class="keyword">clock_t</span> endTime = clock();</span><br><span class="line"></span><br><span class="line">    assert(isSorted(vec));</span><br><span class="line">    <span class="built_in">cout</span>.setf(ios_base::fixed,ios_base::floatfield);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sortName &lt;&lt; <span class="string">" - using time:"</span> &lt;&lt; <span class="keyword">double</span>(endTime - startTime) / CLOCKS_PER_SEC &lt;&lt; <span class="string">"s"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">double</span>(endTime - startTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>冒泡排序是最经典和简单的排序算法之一，它不断的比较两个相邻数的大小，把大的数放到后头。这样经过一次遍历之后最大的数就到了数组的最后头，下一次遍历就将第二大的数放到了倒数第二的位置。不断重复知道完成排序。冒泡排序时间复杂度为O(n^2)，并且是稳定的排序算法，可以原地进行排序（需要O(1)的额外空间）。需要比较次数为O(n^2)，需要最多进行O(n^2)次的交换。实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = vec.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (vec[j] &gt; vec[j+<span class="number">1</span>])&#123;</span><br><span class="line">                swap(vec[j],vec[j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>插入排序的过程就像整理扑克牌一样，可以将整个数组分为已排序和未排序，然后从未排序的部分找出一个数，将它插入到已排序数组中合适的位置。在最坏情况下需要比较次数为O(n^2)，需要最多进行O(n^2)次的赋值。插入排序是稳定的排序算法之一。</p><blockquote><p>但是当排序数据量很小（小于千级）或者元素大致按照顺序排列的时候，插入排序有较好的性能。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>, cur = <span class="number">0</span>, n = vec.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cur = vec[i];</span><br><span class="line">        j = i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; cur &lt; vec[j])&#123;</span><br><span class="line">            vec[j+<span class="number">1</span>] = vec[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        vec[j+<span class="number">1</span>] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序是一种不稳定的排序，一般情况下时间复杂度为O(nlogn)，不过最差情况需要O(n^2)，但是这种情况很少见。快速排序使用分治策略，挑选一个基准数，然后把小于基准的数放到前面，大于基准的数放到后面，最后递归的排序子数组。</p><p>首先是快速排序函数，我们需要一个分割函数来返回基准数的位置，然后递归的排序基准两边的数组：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSorter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = partition(vec, left, right);</span><br><span class="line">        quickSorter(vec, left, mid - <span class="number">1</span>);</span><br><span class="line">        quickSorter(vec, mid + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后就是分割函数，首先选取一个基准数，然后将小于基准的放到前面，大于基准的放到后面，并且返回这个基准的位置：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = vec[right];</span><br><span class="line">    <span class="keyword">int</span> i = left - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = left; j &lt; right; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (vec[j] &lt; pivot)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            swap(vec[i],vec[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(vec[i+<span class="number">1</span>],vec[right]);</span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>堆排序的时间复杂度为O(nlogn)，是一种不稳定的排序算法。<br>首先介绍几个概念：</p><ul><li>完全二叉树(Complete Binary Tree)：一个完全二叉树是一个二叉树除了最后一层全部都是满的，并且最后一层的节点都尽可能的在左边。这意味着一个二叉树如果有k层，那么对于第i层(1&lt;=i&lt;k)它的节点个数为2^(k-1)。</li><li>二叉堆(Binary Heap)：二叉堆是一种特殊的堆，它是一个完全二叉树，并且满足一个特性 - 父节点的值总是保持固定的序关系于任何一个子节点的值，且每个节点的左子树和右子树都是一个二叉堆。如果父节点的值大于任何一个子节点的值就叫”最大堆“；如果是小于就叫“最小堆”</li></ul><p>在堆排序中，我们使用数组来表示二叉堆，因为数组可以很方便的表示一个二叉堆。如果一个父节点的index是i，那么他的左子节点是2n+1，右子节点是2n+2。</p><p>堆排序的步骤如下：</p><ol><li>创建一个堆H[0..n-1]</li><li>把堆首（最大值）和堆尾互换</li><li>把堆的尺寸缩小1，并调用shift_down(0),目的是把新的数组顶端数据调整到相应位置</li><li>重复步骤2，直到堆的尺寸为1</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec, <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> largest = i;</span><br><span class="line">    <span class="keyword">int</span> l = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r = i * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l &lt; n &amp;&amp; vec[l] &gt; vec[largest])</span><br><span class="line">        largest = l;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r &lt; n &amp;&amp; vec[r] &gt; vec[largest])</span><br><span class="line">        largest = r;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (largest != i)&#123;</span><br><span class="line">        swap(vec[i], vec[largest]);</span><br><span class="line">        heapify(vec, n, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = vec.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        heapify(vec, n, i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">        swap(vec[<span class="number">0</span>],vec[i]);</span><br><span class="line">        heapify(vec, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实可以这么理解，首先我们在原数组上构造了一个大顶堆，最大的数字就在堆顶了。在这之后我们就需要把数组升序排好，所以把堆顶放到最后，然后以再构建一个大小为n-1的大顶堆，不断重复这个过程直到整个数组排序好。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><strong>性能测试</strong><br><a href="https://www.jianshu.com/p/334df02eb10a" target="_blank" rel="noopener">https://www.jianshu.com/p/334df02eb10a</a></p><p><strong>冒泡排序</strong><br><a href="https://zh.wikipedia.org/wiki/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F</a><br><a href="https://www.geeksforgeeks.org/bubble-sort/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/bubble-sort/</a></p><p><strong>插入排序</strong><br><a href="https://zhuanlan.zhihu.com/p/35328552" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35328552</a><br><a href="https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F</a><br><a href="https://www.geeksforgeeks.org/insertion-sort/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/insertion-sort/</a></p><p><strong>快速排序</strong><br><a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F</a><br><a href="https://www.geeksforgeeks.org/quick-sort/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/quick-sort/</a><br><a href="http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/" target="_blank" rel="noopener">http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/</a></p><p><strong>堆排序</strong><br><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E5%A0%86" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E5%A0%86</a><br><a href="https://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F</a><br><a href="https://www.geeksforgeeks.org/heap-sort/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/heap-sort/</a></p><p><strong>std::sort</strong><br><a href="https://feihu.me/blog/2014/sgi-std-sort/#introspective-sort" target="_blank" rel="noopener">https://feihu.me/blog/2014/sgi-std-sort/#introspective-sort</a></p><p><strong>一个排序算法可视化比较</strong><br><a href="https://www.toptal.com/developers/sorting-algorithms" target="_blank" rel="noopener">https://www.toptal.com/developers/sorting-algorithms</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="leetcode" scheme="http://yutouwd.github.io/categories/leetcode/"/>
    
      <category term="算法总结" scheme="http://yutouwd.github.io/categories/leetcode/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="leetcode" scheme="http://yutouwd.github.io/tags/leetcode/"/>
    
      <category term="数据结构与算法" scheme="http://yutouwd.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序算法" scheme="http://yutouwd.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>34.Find First and Last Position of Element in Sorted Array</title>
    <link href="http://yutouwd.github.io/posts/932931314/"/>
    <id>http://yutouwd.github.io/posts/932931314/</id>
    <published>2021-08-23T04:14:28.000Z</published>
    <updated>2021-08-23T07:14:05.283Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。<br>如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>进阶：<br>你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？</p><p>示例 1：<br>输入：nums = [5,7,7,8,8,10], target = 8<br>输出：[3,4]</p><p>示例 2：<br>输入：nums = [5,7,7,8,8,10], target = 6<br>输出：[-1,-1]</p><p>示例 3：<br>输入：nums = [], target = 0<br>输出：[-1,-1]</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>用二分查找找到目标数的位置，然后再向前和向后找到它的范围。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, upp = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> finded = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= upp)&#123;</span><br><span class="line">            mid = (low + upp) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)&#123;</span><br><span class="line">                finded = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                upp = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (finded)&#123;</span><br><span class="line">            low = mid;</span><br><span class="line">            upp = mid;</span><br><span class="line">            <span class="keyword">while</span>(low &gt;= <span class="number">0</span> &amp;&amp; nums[low] == target)</span><br><span class="line">                low--;</span><br><span class="line">            <span class="keyword">while</span>(upp &lt; n &amp;&amp; nums[upp] == target)</span><br><span class="line">                upp++;</span><br><span class="line">            <span class="keyword">return</span> &#123;low+<span class="number">1</span>, upp<span class="number">-1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="优化一下"><a href="#优化一下" class="headerlink" title="优化一下"></a>优化一下</h2><p>但是仔细一想，之前找目标数的范围最坏情况下时间复杂度是O(n)了。看了下题解，可以用二分法来找到第一个大于或小于目标数的位置。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target, <span class="keyword">bool</span> lower)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = (<span class="keyword">int</span>)nums.size() - <span class="number">1</span>, ans = (<span class="keyword">int</span>)nums.size();</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target || (lower &amp;&amp; nums[mid] &gt;= target)) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> leftIdx = binarySearch(nums, target, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">int</span> rightIdx = binarySearch(nums, target, <span class="literal">false</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (leftIdx &lt;= rightIdx &amp;&amp; rightIdx &lt; nums.size() &amp;&amp; nums[leftIdx] == target &amp;&amp; nums[rightIdx] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;leftIdx, rightIdx&#125;;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="leetcode" scheme="http://yutouwd.github.io/categories/leetcode/"/>
    
      <category term="medium" scheme="http://yutouwd.github.io/categories/leetcode/medium/"/>
    
    
      <category term="leetcode" scheme="http://yutouwd.github.io/tags/leetcode/"/>
    
      <category term="二分查找" scheme="http://yutouwd.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>231.Power of Two</title>
    <link href="http://yutouwd.github.io/posts/1808807184/"/>
    <id>http://yutouwd.github.io/posts/1808807184/</id>
    <published>2021-08-21T02:34:52.000Z</published>
    <updated>2021-08-21T02:41:12.793Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>判断一个数是不是2的倍数。</p><h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>通过(n &amp; (n-1))是否等于零可以来判断一个数是不是2的倍数。(n &amp; (n-1))会将最小位的1置零。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; (n<span class="number">-1</span>)) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="leetcode" scheme="http://yutouwd.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yutouwd.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>146.LRU Cache</title>
    <link href="http://yutouwd.github.io/posts/426719232/"/>
    <id>http://yutouwd.github.io/posts/426719232/</id>
    <published>2021-08-18T07:43:54.000Z</published>
    <updated>2021-09-12T01:55:29.967Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。<br>实现 LRUCache 类：</p><p>LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存<br>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。<br>void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p><p>进阶：你是否可以在 O(1) 时间复杂度内完成这两种操作？</p><p>示例：</p><p>输入<br>[“LRUCache”, “put”, “put”, “get”, “put”, “get”, “put”, “get”, “get”, “get”]<br>[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]<br>输出<br>[null, null, null, 1, null, -1, null, -1, 3, 4]</p><p>解释<br>LRUCache lRUCache = new LRUCache(2);<br>lRUCache.put(1, 1); // 缓存是 {1=1}<br>lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}<br>lRUCache.get(1);    // 返回 1<br>lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}<br>lRUCache.get(2);    // 返回 -1 (未找到)<br>lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}<br>lRUCache.get(1);    // 返回 -1 (未找到)<br>lRUCache.get(3);    // 返回 3<br>lRUCache.get(4);    // 返回 4</p><p>提示：</p><p>1 &lt;= capacity &lt;= 3000<br>0 &lt;= key &lt;= 10000<br>0 &lt;= value &lt;= 105<br>最多调用 2 * 105 次 get 和 put</p><h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>面试时遇到的一道题目，并没做出来。主要是实现方法是使用一个map和双向链表，map来记录key值和对应的<strong>链表节点</strong>，双向链表来记录缓存的顺序。头部代表最新的数据，尾部代表最旧的数据。同时我们需要的功能有：增加链表头部节点，删除链表节点，删除尾部节点。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双向链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DeLinkedList</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key, value;</span><br><span class="line">    DeLinkedList* prev;</span><br><span class="line">    DeLinkedList* next;</span><br><span class="line">    DeLinkedList() : key(<span class="number">0</span>), value(<span class="number">0</span>), prev(<span class="literal">nullptr</span>), next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    DeLinkedList(<span class="keyword">int</span> _key, <span class="keyword">int</span> _value) : key(_key), value(_value), prev(<span class="literal">nullptr</span>), next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    DeLinkedList* dummyHead;</span><br><span class="line">    DeLinkedList* dummyTail;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, DeLinkedList*&gt; m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LRUCache(<span class="keyword">int</span> _capacity) &#123;</span><br><span class="line">        capacity = _capacity;</span><br><span class="line">        dummyHead = <span class="keyword">new</span> DeLinkedList();</span><br><span class="line">        dummyTail = <span class="keyword">new</span> DeLinkedList();</span><br><span class="line">        dummyHead -&gt; next = dummyTail;</span><br><span class="line">        dummyTail -&gt; prev = dummyHead;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m.find(key) == m.end())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            DeLinkedList* node = m[key];</span><br><span class="line">            moveToHead(node);</span><br><span class="line">            <span class="keyword">return</span> node -&gt; value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m.find(key) == m.end())&#123;</span><br><span class="line">            DeLinkedList* node = <span class="keyword">new</span> DeLinkedList(key, value);</span><br><span class="line">            m[key] = node;</span><br><span class="line">            addToHead(node);</span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; capacity)&#123;</span><br><span class="line">                DeLinkedList* tail = removeTail();</span><br><span class="line">                m.erase(tail -&gt; key);</span><br><span class="line">                <span class="keyword">delete</span> tail;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            DeLinkedList* node = m[key];</span><br><span class="line">            moveToHead(node);</span><br><span class="line">            node -&gt; value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(DeLinkedList* node)</span></span>&#123;</span><br><span class="line">        node -&gt; next -&gt; prev = node -&gt; prev;</span><br><span class="line">        node -&gt; prev -&gt; next = node -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(DeLinkedList* node)</span></span>&#123;</span><br><span class="line">        node -&gt; prev = dummyHead;</span><br><span class="line">        node -&gt; next = dummyHead -&gt; next;</span><br><span class="line">        dummyHead -&gt; next -&gt; prev = node;</span><br><span class="line">        dummyHead -&gt; next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(DeLinkedList* node)</span></span>&#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">DeLinkedList* <span class="title">removeTail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DeLinkedList* node = dummyTail -&gt; prev;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="leetcode" scheme="http://yutouwd.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yutouwd.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>1020.Number of Enclaves</title>
    <link href="http://yutouwd.github.io/posts/3587513103/"/>
    <id>http://yutouwd.github.io/posts/3587513103/</id>
    <published>2021-08-17T08:19:22.000Z</published>
    <updated>2021-08-17T08:40:15.892Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给出一个二维数组 A，每个单元格为 0（代表海）或 1（代表陆地）。</p><p>移动是指在陆地上从一个地方走到另一个地方（朝四个方向之一）或离开网格的边界。</p><p>返回网格中无法在任意次数的移动中离开网格边界的陆地单元格的数量。</p><p>示例 1：</p><p>输入：[[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]<br>输出：3<br>解释：<br>有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。<br>示例 2：</p><p>输入：[[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]<br>输出：0<br>解释：<br>所有 1 都在边界上或可以到达边界。</p><p>提示：</p><p>1 &lt;= A.length &lt;= 500<br>1 &lt;= A[i].length &lt;= 500<br>0 &lt;= A[i][j] &lt;= 1<br>所有行的大小都相同</p><h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>通过边界上的陆地进行深度优先遍历，把遍历过的陆地都置为0。最后再遍历一次整个数组，统计1个的个数。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size(), m = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || j &lt; <span class="number">0</span> || j &gt;= m || grid[i][j] == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        grid[i][j] = <span class="number">0</span>;</span><br><span class="line">        dfs(grid,i<span class="number">-1</span>,j);</span><br><span class="line">        dfs(grid,i+<span class="number">1</span>,j);</span><br><span class="line">        dfs(grid,i,j<span class="number">-1</span>);</span><br><span class="line">        dfs(grid,i,j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numEnclaves</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size(), m = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][<span class="number">0</span>] == <span class="number">1</span>)</span><br><span class="line">                dfs(grid, i, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (grid[i][m<span class="number">-1</span>] == <span class="number">1</span>)</span><br><span class="line">                dfs(grid, i, m<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[<span class="number">0</span>][j] == <span class="number">1</span>)</span><br><span class="line">                dfs(grid, <span class="number">0</span>, j);</span><br><span class="line">            <span class="keyword">if</span> (grid[n<span class="number">-1</span>][j] == <span class="number">1</span>)</span><br><span class="line">                dfs(grid, n<span class="number">-1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>)</span><br><span class="line">                    res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="leetcode" scheme="http://yutouwd.github.io/categories/leetcode/"/>
    
      <category term="medium" scheme="http://yutouwd.github.io/categories/leetcode/medium/"/>
    
    
      <category term="leetcode" scheme="http://yutouwd.github.io/tags/leetcode/"/>
    
      <category term="深度优先" scheme="http://yutouwd.github.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88/"/>
    
  </entry>
  
  <entry>
    <title>695.Max Area of Island &amp; 733.Flood Fill</title>
    <link href="http://yutouwd.github.io/posts/3305314244/"/>
    <id>http://yutouwd.github.io/posts/3305314244/</id>
    <published>2021-07-28T02:22:02.000Z</published>
    <updated>2021-08-17T08:13:09.869Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>两道题目比较相似，都可以用广度优先或深度优先。然后通过修改矩阵中的数值来判断这个点是否遍历过。</p><h2 id="733"><a href="#733" class="headerlink" title="733"></a>733</h2><p>有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。</p><p>给你一个坐标 (sr, sc) 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 newColor，让你重新上色这幅图像。</p><p>为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。</p><p>最后返回经过上色渲染后的图像。</p><p>示例 1:</p><p>输入:<br>image = [[1,1,1],[1,1,0],[1,0,1]]<br>sr = 1, sc = 1, newColor = 2<br>输出: [[2,2,2],[2,2,0],[2,0,1]]<br>解析:<br>在图像的正中间，(坐标(sr,sc)=(1,1)),<br>在路径上所有符合条件的像素点的颜色都被更改成2。<br>注意，右下角的像素没有更改为2，<br>因为它不是在上下左右四个方向上与初始点相连的像素点。<br>注意:</p><p>image 和 image[0] 的长度在范围 [1, 50] 内。<br>给出的初始点将满足 0 &lt;= sr &lt; image.length 和 0 &lt;= sc &lt; image[0].length。<br>image[i][j] 和 newColor 表示的颜色值在范围 [0, 65535]内。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isNeedColor</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; image, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> oriColor)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= n || y &lt; <span class="number">0</span> || y &gt;= m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (image[x][y] == oriColor) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">floodFill</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">int</span> n = image.size(), m = image[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> oriColor = image[sr][sc];</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">res</span><span class="params">(image)</span></span>;</span><br><span class="line">        q.push(make_pair(sr, sc));</span><br><span class="line">        <span class="keyword">while</span>(q.size())&#123;</span><br><span class="line">            <span class="keyword">int</span> times = q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; i++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> cur = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">int</span> x = cur.first, y = cur.second;</span><br><span class="line">                <span class="keyword">if</span> (isNeedColor(image, x, y, n, m, oriColor)&amp;&amp;res[x][y]!=newColor)&#123;</span><br><span class="line">                    res[x][y] = newColor;</span><br><span class="line">                    q.push(make_pair(x<span class="number">-1</span>,y));</span><br><span class="line">                    q.push(make_pair(x+<span class="number">1</span>,y));</span><br><span class="line">                    q.push(make_pair(x,y<span class="number">-1</span>));</span><br><span class="line">                    q.push(make_pair(x,y+<span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="695"><a href="#695" class="headerlink" title="695"></a>695</h2><p>给定一个包含了一些 0 和 1 的非空二维数组 grid 。</p><p>一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。</p><p>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)</p><p>示例 1:</p><p>[[0,0,1,0,0,0,0,1,0,0,0,0,0],<br> [0,0,0,0,0,0,0,1,1,1,0,0,0],<br> [0,1,1,0,1,0,0,0,0,0,0,0,0],<br> [0,1,0,0,1,1,0,0,1,0,1,0,0],<br> [0,1,0,0,1,1,0,0,1,1,1,0,0],<br> [0,0,0,0,0,0,0,0,0,0,1,0,0],<br> [0,0,0,0,0,0,0,1,1,1,0,0,0],<br> [0,0,0,0,0,0,0,1,1,0,0,0,0]]<br>对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。</p><p>示例 2:</p><p>[[0,0,0,0,0,0,0,0]]<br>对于上面这个给定的矩阵, 返回 0。</p><p>注意: 给定的矩阵grid 的长度和宽度都不超过 50。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">computeSize</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; island, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.push(make_pair(x,y));</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(q.size())&#123;</span><br><span class="line">            <span class="keyword">int</span> times = q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; i++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> cur = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">int</span> cx = cur.first, cy = cur.second;</span><br><span class="line">                <span class="keyword">if</span> (isValid(cx, cy) &amp;&amp; island[cx][cy] == <span class="number">1</span>)&#123;</span><br><span class="line">                    size++;</span><br><span class="line">                    island[cx][cy] = <span class="number">0</span>;</span><br><span class="line">                    q.push(make_pair(cx+<span class="number">1</span>,cy));</span><br><span class="line">                    q.push(make_pair(cx<span class="number">-1</span>,cy));</span><br><span class="line">                    q.push(make_pair(cx,cy+<span class="number">1</span>));</span><br><span class="line">                    q.push(make_pair(cx,cy<span class="number">-1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">island</span><span class="params">(grid)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        n = island.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        m = island[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (island[i][j] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> curSize = computeSize(island, i, j);</span><br><span class="line">                res = max(res, curSize);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="leetcode" scheme="http://yutouwd.github.io/categories/leetcode/"/>
    
      <category term="mudium" scheme="http://yutouwd.github.io/categories/leetcode/mudium/"/>
    
    
      <category term="leetcode" scheme="http://yutouwd.github.io/tags/leetcode/"/>
    
      <category term="广度优先" scheme="http://yutouwd.github.io/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88/"/>
    
  </entry>
  
  <entry>
    <title>567.Permutation in String</title>
    <link href="http://yutouwd.github.io/posts/3971953535/"/>
    <id>http://yutouwd.github.io/posts/3971953535/</id>
    <published>2021-07-27T14:55:19.000Z</published>
    <updated>2021-07-27T14:58:43.861Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。</p><p>换句话说，第一个字符串的排列之一是第二个字符串的 子串 。 </p><p>示例 1：<br>输入: s1 = “ab” s2 = “eidbaooo”<br>输出: True<br>解释: s2 包含 s1 的排列之一 (“ba”).</p><p>示例 2：<br>输入: s1= “ab” s2 = “eidboaoo”<br>输出: False</p><p>提示：<br>1 &lt;= s1.length, s2.length &lt;= 104<br>s1 和 s2 仅包含小写字母</p><h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>判断字符串二中是否有和字符串中一样的排列（有相同的字符和他们的数量）。使用滑动窗口，记录字符串二窗口中的各个字符数。如果字符只有小写的话，使用数组会方便些。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = s1.size(), n2 = s2.size();</span><br><span class="line">        <span class="keyword">if</span> (n1 &gt; n2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n1; i++)&#123;</span><br><span class="line">            v1[(s1[i] - <span class="string">'a'</span>)]++;</span><br><span class="line">            v2[(s2[i] - <span class="string">'a'</span>)]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (v1 == v2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n1; i &lt; n2; i++)&#123;</span><br><span class="line">            v2[(s2[i-n1] - <span class="string">'a'</span>)]--;</span><br><span class="line">            v2[(s2[i] - <span class="string">'a'</span>)]++;</span><br><span class="line">            <span class="keyword">if</span> (v1 == v2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="leetcode" scheme="http://yutouwd.github.io/categories/leetcode/"/>
    
      <category term="medium" scheme="http://yutouwd.github.io/categories/leetcode/medium/"/>
    
    
      <category term="leetcode" scheme="http://yutouwd.github.io/tags/leetcode/"/>
    
      <category term="滑动窗口" scheme="http://yutouwd.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>3.Longest Substring Without Repeating Characters</title>
    <link href="http://yutouwd.github.io/posts/1224454559/"/>
    <id>http://yutouwd.github.io/posts/1224454559/</id>
    <published>2021-07-27T14:20:29.000Z</published>
    <updated>2021-07-27T14:28:47.083Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given a string s, find the length of the longest substring without repeating characters.</p><p>Example 1:<br>Input: s = “abcabcbb”<br>Output: 3<br>Explanation: The answer is “abc”, with the length of 3.</p><p>Example 2:<br>Input: s = “bbbbb”<br>Output: 1<br>Explanation: The answer is “b”, with the length of 1.</p><p>Example 3:<br>Input: s = “pwwkew”<br>Output: 3<br>Explanation: The answer is “wke”, with the length of 3.<br>Notice that the answer must be a substring, “pwke” is a subsequence and not a substring.</p><p>Example 4:<br>Input: s = “”<br>Output: 0</p><p>Constraints:<br>0 &lt;= s.length &lt;= 5 * 104<br>s consists of English letters, digits, symbols and spaces.</p><h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>找到字符串的最长无重复字符的子串。使用滑动窗口来记录当前字串存在的字符，及其数量。如果当前没有重复的字符，那么后指针就往后移动，如果有，那么就将前指针往后移动。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        m[s[<span class="number">0</span>]]++;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>, curLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (m.find(s[j]) != m.end() &amp;&amp; m[s[j]] &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">                m[s[i++]]--;</span><br><span class="line">                curLen--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j &lt; n)&#123;</span><br><span class="line">                m[s[j++]]++;</span><br><span class="line">                curLen++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curLen &gt; maxLen)</span><br><span class="line">                maxLen = curLen;</span><br><span class="line">            <span class="keyword">if</span> (j == n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="leetcode" scheme="http://yutouwd.github.io/categories/leetcode/"/>
    
      <category term="medium" scheme="http://yutouwd.github.io/categories/leetcode/medium/"/>
    
    
      <category term="leetcode" scheme="http://yutouwd.github.io/tags/leetcode/"/>
    
      <category term="hashmap" scheme="http://yutouwd.github.io/tags/hashmap/"/>
    
      <category term="滑动窗口" scheme="http://yutouwd.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>704.Binary Search</title>
    <link href="http://yutouwd.github.io/posts/1944760669/"/>
    <id>http://yutouwd.github.io/posts/1944760669/</id>
    <published>2021-07-22T13:47:41.000Z</published>
    <updated>2021-07-22T13:49:37.270Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.</p><p>You must write an algorithm with O(log n) runtime complexity. </p><p>Example 1:<br>Input: nums = [-1,0,3,5,9,12], target = 9<br>Output: 4<br>Explanation: 9 exists in nums and its index is 4</p><p>Example 2:<br>Input: nums = [-1,0,3,5,9,12], target = 2<br>Output: -1<br>Explanation: 2 does not exist in nums so return -1</p><h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right= nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="leetcode" scheme="http://yutouwd.github.io/categories/leetcode/"/>
    
      <category term="easy" scheme="http://yutouwd.github.io/categories/leetcode/easy/"/>
    
    
      <category term="leetcode" scheme="http://yutouwd.github.io/tags/leetcode/"/>
    
      <category term="二分查找" scheme="http://yutouwd.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>Matlab 画图小技巧笔记</title>
    <link href="http://yutouwd.github.io/posts/3250640614/"/>
    <id>http://yutouwd.github.io/posts/3250640614/</id>
    <published>2021-06-04T20:03:03.000Z</published>
    <updated>2021-09-14T07:24:29.464Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>记录一下用过的一些Matlab画图技巧📈<br>持续补充中</p><a id="more"></a><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h2><h2 id="箱线图"><a href="#箱线图" class="headerlink" title="箱线图"></a>箱线图</h2><p>箱线图x轴标签方向<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boxplot(X, <span class="string">'Labels'</span>, &#123;<span class="string">'40 R-L'</span>, <span class="string">'40 L-R'</span>, <span class="string">'50 R-L'</span>, <span class="string">'50 L-R'</span>, <span class="string">'60 R-L'</span>, <span class="string">'60 L-R'</span>&#125;, <span class="string">'LabelOrientation'</span>, <span class="string">'inline'</span>);</span><br></pre></td></tr></table></figure></p><h1 id="修改属性"><a href="#修改属性" class="headerlink" title="修改属性"></a>修改属性</h1><h2 id="坐标轴相关"><a href="#坐标轴相关" class="headerlink" title="坐标轴相关"></a>坐标轴相关</h2><h3 id="获取坐标轴对象"><a href="#获取坐标轴对象" class="headerlink" title="获取坐标轴对象"></a>获取坐标轴对象</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 可以直接用gca命令来获取</span></span><br><span class="line"><span class="comment">% get current axis</span></span><br><span class="line">ax = gca;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 可以直接更改坐标轴对象的属性</span></span><br><span class="line"><span class="comment">% 更改坐标轴颜色</span></span><br><span class="line">ax.Color = <span class="string">'blue'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 或者使用set来设置坐标轴对象的属性（早期版本只能通过set来设置）</span></span><br><span class="line"><span class="comment">% 更改坐标轴刻度字体大小</span></span><br><span class="line">set(gca, <span class="string">'FontSize'</span>, <span class="number">30</span>)</span><br><span class="line"><span class="comment">% 设置字体加粗</span></span><br><span class="line">set(gca, <span class="string">'FontWeight, '</span>bold')</span><br></pre></td></tr></table></figure><p>关于坐标轴对象属性的文档在这里👇：</p><p><a href="https://www.mathworks.com/help/matlab/ref/matlab.graphics.axis.axes-properties.html" target="_blank" rel="noopener">https://www.mathworks.com/help/matlab/ref/matlab.graphics.axis.axes-properties.html</a></p><h3 id="设置显示网格（可以只显示单一轴的网格）"><a href="#设置显示网格（可以只显示单一轴的网格）" class="headerlink" title="设置显示网格（可以只显示单一轴的网格）"></a>设置显示网格（可以只显示单一轴的网格）</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 只显示x轴网格</span></span><br><span class="line"><span class="comment">% 通过on和off来设置显示与否</span></span><br><span class="line">set(gca, <span class="string">'XGrid'</span>, <span class="string">'on'</span>, <span class="string">'YGrid'</span>, <span class="string">'off'</span>)</span><br></pre></td></tr></table></figure><h3 id="设置是否显示坐标轴刻度"><a href="#设置是否显示坐标轴刻度" class="headerlink" title="设置是否显示坐标轴刻度"></a>设置是否显示坐标轴刻度</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 隐藏坐标轴刻度</span></span><br><span class="line"><span class="comment">% 同样可以控制只隐藏特定轴</span></span><br><span class="line">set(gca, <span class="string">'XTickLabel'</span>, [], <span class="string">'YTickLabel'</span>,[])</span><br></pre></td></tr></table></figure><h2 id="图例相关"><a href="#图例相关" class="headerlink" title="图例相关"></a>图例相关</h2><h3 id="获取图例对象"><a href="#获取图例对象" class="headerlink" title="获取图例对象"></a>获取图例对象</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">leg = <span class="built_in">legend</span>(...)</span><br></pre></td></tr></table></figure><p>图例对象的相关属性文档：<br><a href="https://www.mathworks.com/help/matlab/ref/matlab.graphics.illustration.legend-properties.html" target="_blank" rel="noopener">https://www.mathworks.com/help/matlab/ref/matlab.graphics.illustration.legend-properties.html</a></p><h3 id="设置图例方向"><a href="#设置图例方向" class="headerlink" title="设置图例方向"></a>设置图例方向</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 可以选择横向或竖向</span></span><br><span class="line">leg.Orientation = <span class="string">'horizontal'</span>;</span><br><span class="line">leg.Orientation = <span class="string">'vertical'</span>;</span><br></pre></td></tr></table></figure><h3 id="设置多列显示"><a href="#设置多列显示" class="headerlink" title="设置多列显示"></a>设置多列显示</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 可以通过调节列的数量来做到多列显示</span></span><br><span class="line">leg.NumColumns = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h3 id="设置每一个图例的大小"><a href="#设置每一个图例的大小" class="headerlink" title="设置每一个图例的大小"></a>设置每一个图例的大小</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">leg.ItemTokenSize = [<span class="number">216</span>,<span class="number">40</span>];</span><br></pre></td></tr></table></figure><h1 id="美化小技巧"><a href="#美化小技巧" class="headerlink" title="美化小技巧"></a>美化小技巧</h1><h2 id="颜色搭配"><a href="#颜色搭配" class="headerlink" title="颜色搭配"></a>颜色搭配</h2><p>这里推荐知乎博主的搭配：</p><img src="/posts/3250640614/m1.jpg"><p>以及日本传统色这个网站，可以找到很多不错的颜色：<br><a href="https://nipponcolors.com/" target="_blank" rel="noopener">https://nipponcolors.com/</a></p><h2 id="画图速查表"><a href="#画图速查表" class="headerlink" title="画图速查表"></a>画图速查表</h2><p>非常有用的画图速查表：<a href="https://github.com/Pjer-zhang/matlabPlotCheatsheet" target="_blank" rel="noopener">https://github.com/Pjer-zhang/matlabPlotCheatsheet</a></p><img src="/posts/3250640614/m2.png"><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>一些小技巧和基础知识：<br><a href="https://zhuanlan.zhihu.com/p/82421043" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/82421043</a><br>figure对象的相关知识：<br><a href="https://zhuanlan.zhihu.com/p/47487701" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/47487701</a><br>画图颜色搭配：<br><a href="https://zhuanlan.zhihu.com/p/58810578" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/58810578</a><br>画图速查表：<br><a href="https://github.com/Pjer-zhang/matlabPlotCheatsheet" target="_blank" rel="noopener">https://github.com/Pjer-zhang/matlabPlotCheatsheet</a><br><a href="https://zhuanlan.zhihu.com/p/112229373" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/112229373</a><br>图坐标轴相关属性：<br><a href="https://www.mathworks.com/help/matlab/ref/matlab.graphics.axis.axes-properties.html" target="_blank" rel="noopener">https://www.mathworks.com/help/matlab/ref/matlab.graphics.axis.axes-properties.html</a><br>图例相关属性：<br><a href="https://www.mathworks.com/help/matlab/ref/matlab.graphics.illustration.legend-properties.html" target="_blank" rel="noopener">https://www.mathworks.com/help/matlab/ref/matlab.graphics.illustration.legend-properties.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下用过的一些Matlab画图技巧📈&lt;br&gt;持续补充中&lt;/p&gt;
    
    </summary>
    
      <category term="科研" scheme="http://yutouwd.github.io/categories/%E7%A7%91%E7%A0%94/"/>
    
    
      <category term="Matlab" scheme="http://yutouwd.github.io/tags/Matlab/"/>
    
      <category term="画图" scheme="http://yutouwd.github.io/tags/%E7%94%BB%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>72.Edit Distance</title>
    <link href="http://yutouwd.github.io/posts/3404414355/"/>
    <id>http://yutouwd.github.io/posts/3404414355/</id>
    <published>2021-01-22T01:17:32.000Z</published>
    <updated>2021-09-27T07:14:56.220Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.</p><p>You have the following three operations permitted on a word:</p><p>Insert a character<br>Delete a character<br>Replace a character</p><p>Example 1:<br>Input: word1 = “horse”, word2 = “ros”<br>Output: 3<br>Explanation:<br>horse -&gt; rorse (replace ‘h’ with ‘r’)<br>rorse -&gt; rose (remove ‘r’)<br>rose -&gt; ros (remove ‘e’)</p><p>Example 2:<br>Input: word1 = “intention”, word2 = “execution”<br>Output: 5<br>Explanation:<br>intention -&gt; inention (remove ‘t’)<br>inention -&gt; enention (replace ‘i’ with ‘e’)<br>enention -&gt; exention (replace ‘n’ with ‘x’)<br>exention -&gt; exection (replace ‘n’ with ‘c’)<br>exection -&gt; execution (insert ‘u’)</p><h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>没想到面试里上来就来了一道hard题目，好在在提示下写出来了差不多。最主要就是状态转移方程代表的意义，dp[i][j]代表的是word1前i位转换为word2前j位需要最少的步骤。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = word1.length();</span><br><span class="line">        <span class="keyword">int</span> m = word2.length();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> m;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (m+<span class="number">1</span>,<span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n+<span class="number">1</span>; i++)</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m+<span class="number">1</span>; j++)</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m+<span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>])&#123;</span><br><span class="line">                    dp[i][j] = min(dp[i<span class="number">-1</span>][j<span class="number">-1</span>],min(dp[i<span class="number">-1</span>][j]+<span class="number">1</span>,dp[i][j<span class="number">-1</span>]+<span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = min(dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>, min(dp[i<span class="number">-1</span>][j]+<span class="number">1</span>, dp[i][j<span class="number">-1</span>]+<span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="583-Delete-Operation-for-Two-Strings"><a href="#583-Delete-Operation-for-Two-Strings" class="headerlink" title="583. Delete Operation for Two Strings"></a>583. Delete Operation for Two Strings</h1><p>Given two strings word1 and word2, return the minimum number of steps required to make word1 and word2 the same.<br>In one step, you can delete exactly one character in either string.</p><p>Example 1:<br>Input: word1 = “sea”, word2 = “eat”<br>Output: 2<br>Explanation: You need one step to make “sea” to “ea” and another step to make “eat” to “ea”.</p><p>Example 2:<br>Input: word1 = “leetcode”, word2 = “etco”<br>Output: 4</p><p>Constraints:<br>1 &lt;= word1.length, word2.length &lt;= 500<br>word1 and word2 consist of only lowercase English letters.</p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>这题其实是编辑距离更简单的版本，没有了插入和替换，但是做每日一题的时候还是想不出来怎么做。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = word1.size(), m = word2.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m+<span class="number">1</span>,<span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> a = word1[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">                <span class="keyword">char</span> b = word2[j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span> (a == b)</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = min(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="leetcode" scheme="http://yutouwd.github.io/categories/leetcode/"/>
    
      <category term="hard" scheme="http://yutouwd.github.io/categories/leetcode/hard/"/>
    
    
      <category term="leetcode" scheme="http://yutouwd.github.io/tags/leetcode/"/>
    
      <category term="动态规划" scheme="http://yutouwd.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>1018.Binary Prefix Divisble by 5</title>
    <link href="http://yutouwd.github.io/posts/2948955516/"/>
    <id>http://yutouwd.github.io/posts/2948955516/</id>
    <published>2021-01-14T09:13:45.000Z</published>
    <updated>2021-01-22T01:17:02.994Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given an array A of 0s and 1s, consider N_i: the i-th subarray from A[0] to A[i] interpreted as a binary number (from most-significant-bit to least-significant-bit.)</p><p>Return a list of booleans answer, where answer[i] is true if and only if N_i is divisible by 5.</p><p>Example 1:<br>Input: [0,1,1]<br>Output: [true,false,false]<br>Explanation:<br>The input numbers in binary are 0, 01, 011; which are 0, 1, and 3 in base-10.  Only the first number is divisible by 5, so answer[0] is true.</p><p>Example 2:<br>Input: [1,1,1]<br>Output: [false,false,false]</p><p>Example 3:<br>Input: [0,1,1,1,1,1]<br>Output: [true,false,false,false,true,false]</p><p>Example 4:<br>Input: [1,1,1,0,1]<br>Output: [false,false,false,false,false]</p><h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>想法是用一个数来记录当前数字，到下一位时就将其左移一位，然后在加上A中对应位。不过数字会超出范围，看了下讨论发现可以用取10的模来避免越界，因为能被5整除的数只需要考虑最后一位是不是5或0即可。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">prefixesDivBy5</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">ans</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            num = num &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (A[i] == <span class="number">1</span>) num++;</span><br><span class="line">            ans[i] = (num % <span class="number">5</span> == <span class="number">0</span>);</span><br><span class="line">            num %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="leetcode" scheme="http://yutouwd.github.io/categories/leetcode/"/>
    
      <category term="easy" scheme="http://yutouwd.github.io/categories/leetcode/easy/"/>
    
    
      <category term="leetcode" scheme="http://yutouwd.github.io/tags/leetcode/"/>
    
      <category term="位操作" scheme="http://yutouwd.github.io/tags/%E4%BD%8D%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>116.Populating Next Right Pointer in Each Node</title>
    <link href="http://yutouwd.github.io/posts/3551767496/"/>
    <id>http://yutouwd.github.io/posts/3551767496/</id>
    <published>2021-01-11T10:15:32.000Z</published>
    <updated>2021-07-31T08:35:24.832Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:</p><p>struct Node {<br>  int val;<br>  Node <em>left;<br>  Node </em>right;<br>  Node *next;<br>}<br>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</p><p>Initially, all next pointers are set to NULL.</p><p>Follow up:</p><p>You may only use constant extra space.<br>Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem.</p><h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用一个队列来记录一层的节点。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span></span><br><span class="line"><span class="comment">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        Node* ret = root;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ret;</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> n = q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">                Node* tmp =  q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                tmp -&gt; next = q.front();</span><br><span class="line">                <span class="keyword">if</span> (tmp -&gt; left) q.push(tmp -&gt; left);</span><br><span class="line">                <span class="keyword">if</span> (tmp -&gt; right)q.push(tmp -&gt; right);</span><br><span class="line">            &#125;</span><br><span class="line">            Node* tmp = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            tmp -&gt; next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">if</span> (tmp -&gt; left) q.push(tmp -&gt; left);</span><br><span class="line">            <span class="keyword">if</span> (tmp -&gt; right)q.push(tmp -&gt; right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不过这样使用的空间就有O(n)了，并不是常量空间。可以用递归的方法就不需要额外的空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (root -&gt; left)&#123;</span><br><span class="line">            root -&gt; left -&gt; next = root -&gt; right;</span><br><span class="line">            <span class="keyword">if</span> (root -&gt; right &amp;&amp; root -&gt; next)&#123;</span><br><span class="line">                root -&gt; right -&gt; next = root -&gt; next -&gt; left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        connect(root -&gt; left);</span><br><span class="line">        connect(root -&gt; right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="leetcode" scheme="http://yutouwd.github.io/categories/leetcode/"/>
    
      <category term="medium" scheme="http://yutouwd.github.io/categories/leetcode/medium/"/>
    
    
      <category term="leetcode" scheme="http://yutouwd.github.io/tags/leetcode/"/>
    
      <category term="tree" scheme="http://yutouwd.github.io/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>103.Binary Tree Zigzag Level Order Traversal</title>
    <link href="http://yutouwd.github.io/posts/2376334793/"/>
    <id>http://yutouwd.github.io/posts/2376334793/</id>
    <published>2020-12-19T09:16:40.000Z</published>
    <updated>2020-12-19T09:46:16.356Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p><p>For example:<br>Given binary tree [3,9,20,null,null,15,7],<br>    3<br>   / \<br>  9  20<br>    /  \<br>   15   7<br>return its zigzag level order traversal as:<br>[<br>  [3],<br>  [20,9],<br>  [15,7]<br>]</p><h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用双向队列，奇数行的从左往右，偶数行的从右往左。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">zigzagLevelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">deque</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push_back(root);</span><br><span class="line">        <span class="keyword">bool</span> front = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> n = q.size();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">            <span class="keyword">if</span> (front)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                    TreeNode* tmp = q.front();</span><br><span class="line">                    q.pop_front();</span><br><span class="line">                    vec.push_back(tmp -&gt; val);</span><br><span class="line">                    <span class="keyword">if</span> (tmp -&gt; left) q.push_back(tmp -&gt; left);</span><br><span class="line">                    <span class="keyword">if</span> (tmp -&gt; right)q.push_back(tmp -&gt; right);</span><br><span class="line">                &#125;</span><br><span class="line">                front = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                    TreeNode* tmp  = q.back();</span><br><span class="line">                    q.pop_back();</span><br><span class="line">                    vec.push_back(tmp -&gt; val);</span><br><span class="line">                    <span class="keyword">if</span> (tmp -&gt; right)q.push_front(tmp -&gt; right);</span><br><span class="line">                    <span class="keyword">if</span> (tmp -&gt; left) q.push_front(tmp -&gt; left);</span><br><span class="line">                &#125;</span><br><span class="line">                front = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="leetcode" scheme="http://yutouwd.github.io/categories/leetcode/"/>
    
      <category term="medium" scheme="http://yutouwd.github.io/categories/leetcode/medium/"/>
    
    
      <category term="leetcode" scheme="http://yutouwd.github.io/tags/leetcode/"/>
    
      <category term="tree" scheme="http://yutouwd.github.io/tags/tree/"/>
    
  </entry>
  
</feed>
