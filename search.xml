<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>195.Tenth Line</title>
    <url>/posts/633169037/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given a text file file.txt, print just the 10th line of the file.</p>
<p>Example:</p>
<p>Assume that file.txt has the following content:</p>
<p>Line 1<br>Line 2<br>Line 3<br>Line 4<br>Line 5<br>Line 6<br>Line 7<br>Line 8<br>Line 9<br>Line 10</p>
<p>Your script should output the tenth line, which is:<br>Line 10</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">'NR==10'</span> file.txt</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>268.Missing Number</title>
    <url>/posts/2942226103/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array.</p>
<p>Example 1:<br>Input: [3,0,1]<br>Output: 2</p>
<p>Example 2:<br>Input: [9,6,4,2,3,5,7,0,1]<br>Output: 8</p>
<p>Note:<br>Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>最先想到的方法就是使用一个bool数组，大小要比输入的数组大一，全部初始化为true。然后遍历输入的数组，已输入数组中的数字为索引，将bool数组中的对应位置改为false。最后再遍历一遍bool数组，遇到了true就返回索引值。</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; miss(nums.size() + <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">            miss[nums[i]] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; nums.size() + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (miss[i])</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 24 ms, faster than 81.97% of C++ online submissions for Missing Number.<br>Memory Usage: 10 MB, less than 45.10% of C++ online submissions for Missing Number.</p>
<h1 id="高票解法"><a href="#高票解法" class="headerlink" title="高票解法"></a>高票解法</h1><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h2><p>看了下题解，可以使用哈希表：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.find(i) == s.end())</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>但是不知道为什么速度那么慢</p>
<p>Runtime: 68 ms, faster than 6.52% of C++ online submissions for Missing Number.<br>Memory Usage: 17.6 MB, less than 5.88% of C++ online submissions for Missing Number.</p>
<p>还可以使用数学方法，把整个数组加起来和0~n的等差数列求差，差值就是缺失值。为了防止数值溢出可以用边加边减的方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; nums.size(); i++)</span><br><span class="line">            sum += nums[i] - i;</span><br><span class="line">        sum -= i;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 24 ms, faster than 81.97% of C++ online submissions for Missing Number.<br>Memory Usage: 9.9 MB, less than 72.55% of C++ online submissions for Missing Number.</p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hashmap</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的几种遍历</title>
    <url>/posts/3359640998/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="Leetcode-144-二叉树前序遍历"><a href="#Leetcode-144-二叉树前序遍历" class="headerlink" title="Leetcode #144 二叉树前序遍历"></a>Leetcode #144 二叉树前序遍历</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preoderTraverse</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, TreeNode* node)</span></span>&#123;</span><br><span class="line">        nums.push_back(node -&gt; val);</span><br><span class="line">        <span class="keyword">if</span> (node -&gt; left) preoderTraverse(nums, node -&gt; left);</span><br><span class="line">        <span class="keyword">if</span> (node -&gt; right) preoderTraverse(nums, node -&gt; right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        preoderTraverse(nums, root);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 4 ms, faster than 59.84% of C++ online submissions for Binary Tree Preorder Traversal.<br>Memory Usage: 9.4 MB, less than 53.45% of C++ online submissions for Binary Tree Preorder Traversal.</p>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        s.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            TreeNode* tmp = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            nums.push_back(tmp -&gt; val);</span><br><span class="line">            <span class="keyword">if</span> (tmp -&gt; right) s.push(tmp -&gt; right);</span><br><span class="line">            <span class="keyword">if</span> (tmp -&gt; left) s.push(tmp -&gt; left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 4 ms, faster than 59.84% of C++ online submissions for Binary Tree Preorder Traversal.<br>Memory Usage: 9.1 MB, less than 100.00% of C++ online submissions for Binary Tree Preorder Traversal.</p>
<h2 id="Leetcode-94-二叉树中序遍历"><a href="#Leetcode-94-二叉树中序遍历" class="headerlink" title="Leetcode #94 二叉树中序遍历"></a>Leetcode #94 二叉树中序遍历</h2><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorderTraverse</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, TreeNode* node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node -&gt; left) inorderTraverse(nums, node -&gt; left);</span><br><span class="line">        nums.push_back(node -&gt; val);</span><br><span class="line">        <span class="keyword">if</span> (node -&gt; right) inorderTraverse(nums, node -&gt; right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        inorderTraverse(nums, root);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 4 ms, faster than 58.95% of C++ online submissions for Binary Tree Inorder Traversal.<br>Memory Usage: 9.5 MB, less than 42.00% of C++ online submissions for Binary Tree Inorder Traversal.</p>
<h3 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur || !s.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span> (cur)&#123;</span><br><span class="line">                s.push(cur);</span><br><span class="line">                cur = cur -&gt; left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cur = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                nums.push_back(cur -&gt; val);</span><br><span class="line">                cur = cur -&gt; right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Leetcode-145-二叉树后序遍历"><a href="#Leetcode-145-二叉树后序遍历" class="headerlink" title="Leetcode # 145 二叉树后序遍历"></a>Leetcode # 145 二叉树后序遍历</h2><h3 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postorderTraverse</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, TreeNode* node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node -&gt; left) postorderTraverse(nums, node -&gt; left);</span><br><span class="line">        <span class="keyword">if</span> (node -&gt; right) postorderTraverse(nums, node -&gt; right);</span><br><span class="line">        nums.push_back(node -&gt; val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        postorderTraverse(nums, root);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 4 ms, faster than 59.20% of C++ online submissions for Binary Tree Postorder Traversal.<br>Memory Usage: 9.4 MB, less than 38.71% of C++ online submissions for Binary Tree Postorder Traversal.</p>
<h3 id="迭代-2"><a href="#迭代-2" class="headerlink" title="迭代"></a>迭代</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        s.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            TreeNode* tmp = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            nums.push_back(tmp -&gt; val);</span><br><span class="line">            <span class="keyword">if</span> (tmp -&gt; left) s.push(tmp -&gt; left);</span><br><span class="line">            <span class="keyword">if</span> (tmp -&gt; right) s.push(tmp -&gt; right);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 0 ms, faster than 100.00% of C++ online submissions for Binary Tree Postorder Traversal.<br>Memory Usage: 9.1 MB, less than 93.55% of C++ online submissions for Binary Tree Postorder Traversal.</p>
<h2 id="Morris遍历方法"><a href="#Morris遍历方法" class="headerlink" title="Morris遍历方法"></a>Morris遍历方法</h2><h3 id="中序"><a href="#中序" class="headerlink" title="中序"></a>中序</h3><p>参考<a href="https://www.jianshu.com/p/484f587c967c" target="_blank" rel="noopener">https://www.jianshu.com/p/484f587c967c</a><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">getPredecessor</span><span class="params">(TreeNode* node)</span></span>&#123;</span><br><span class="line">        TreeNode* p = node;</span><br><span class="line">        <span class="keyword">if</span> (p -&gt; left)&#123;</span><br><span class="line">            p = p -&gt; left;</span><br><span class="line">            <span class="keyword">while</span>(p -&gt; right &amp;&amp; p -&gt; right != node)</span><br><span class="line">                p = p -&gt; right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur)&#123;</span><br><span class="line">            <span class="keyword">if</span> (cur -&gt; left == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                nums.push_back(cur -&gt; val);</span><br><span class="line">                cur = cur -&gt; right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                TreeNode* pre = getPredecessor(cur);</span><br><span class="line">                <span class="keyword">if</span> (pre -&gt; right == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    pre -&gt; right = cur;</span><br><span class="line">                    cur = cur -&gt; left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pre -&gt; right == cur)&#123;</span><br><span class="line">                    pre -&gt; right = <span class="literal">NULL</span>;</span><br><span class="line">                    nums.push_back(cur -&gt; val);</span><br><span class="line">                    cur = cur -&gt; right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>medium</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>tree</tag>
        <tag>Morris</tag>
      </tags>
  </entry>
  <entry>
    <title>590.N-Ary Tree Postorder Traversal</title>
    <url>/posts/2778829074/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>树的后序遍历，递归的方法和前序的类似，只不过需要调换下递归调用的顺序<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postorder_traverse</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, Node* tree_node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> iter : tree_node -&gt; children)</span><br><span class="line">            postorder_traverse(nums, iter);</span><br><span class="line">        nums.push_back(tree_node -&gt; val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorder(Node* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        postorder_traverse(nums, root);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Runtime: 100 ms, faster than 12.21% of C++ online submissions for N-ary Tree Postorder Traversal.<br>Memory Usage: 56.7 MB, less than 20.00% of C++ online submissions for N-ary Tree Postorder Traversal.</p>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>迭代的方法也和前序的类似，不过for的时候是要从前到后，因为最后的时候要把整个数组翻转过来，所以要让右边的最先pop出来。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorder(Node* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="built_in">stack</span>&lt;Node*&gt; s;</span><br><span class="line">        s.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            Node* tmp = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            nums.push_back(tmp -&gt; val);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tmp -&gt; children.size(); i++)</span><br><span class="line">                s.push(tmp -&gt; children[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 60 ms, faster than 84.99% of C++ online submissions for N-ary Tree Postorder Traversal.<br>Memory Usage: 56.5 MB, less than 20.00% of C++ online submissions for N-ary Tree Postorder Traversal.</p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>589.N-Ary Tree Preorder Traversal</title>
    <url>/posts/1370213866/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given an n-ary tree, return the preorder traversal of its nodes’ values.</p>
<p>Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).</p>
<p>Follow up:</p>
<p>Recursive solution is trivial, could you do it iteratively?</p>
<p>Example 1:</p>
<p>Input: root = [1,null,3,2,4,null,5,6]<br>Output: [1,3,5,6,2,4]<br>Example 2:</p>
<p>Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]<br>Output: [1,2,3,6,7,11,14,4,8,12,5,9,13,10]</p>
<p>Constraints:</p>
<p>The height of the n-ary tree is less than or equal to 1000<br>The total number of nodes is between [0, 10^4]</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>前序遍历一个树，树的子节点可能有多个，使用递归的方法<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorder_traverse</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, Node* tree_node)</span></span>&#123;</span><br><span class="line">        nums.push_back(tree_node -&gt; val);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> iter : tree_node -&gt; children)&#123;</span><br><span class="line">            preorder_traverse(nums, iter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorder(Node* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        preorder_traverse(nums, root);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Runtime: 60 ms, faster than 85.95% of C++ online submissions for N-ary Tree Preorder Traversal.<br>Memory Usage: 56.7 MB, less than 10.53% of C++ online submissions for N-ary Tree Preorder Traversal.</p>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>迭代的方法：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorder(Node* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="built_in">stack</span>&lt;Node*&gt; s;</span><br><span class="line">        s.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!s.empty())&#123;</span><br><span class="line">            Node* tmp = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            nums.push_back(tmp -&gt; val);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = tmp -&gt; children.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                s.push(tmp -&gt; children[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Runtime: 60 ms, faster than 85.95% of C++ online submissions for N-ary Tree Preorder Traversal.<br>Memory Usage: 56.5 MB, less than 10.53% of C++ online submissions for N-ary Tree Preorder Traversal.</p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>234.Palindrome Linked List</title>
    <url>/posts/3702077338/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given a singly linked list, determine if it is a palindrome.</p>
<p>Example 1:<br>Input: 1-&gt;2<br>Output: false</p>
<p>Example 2:<br>Input: 1-&gt;2-&gt;2-&gt;1<br>Output: true</p>
<p>Follow up:<br>Could you do it in O(n) time and O(1) space?</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !(head -&gt; next)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        ListNode* p1 = head;</span><br><span class="line">        <span class="keyword">while</span>(p1)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            p1 = p1 -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = len / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> mod = len % <span class="number">2</span>;</span><br><span class="line">        ListNode* p2 = head;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            s.push(p2 -&gt; val);</span><br><span class="line">            p2 = p2 -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mod)</span><br><span class="line">            p2 = p2 -&gt; next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">if</span> (tmp != p2 -&gt; val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p2 = p2 -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 16 ms, faster than 98.87% of C++ online submissions for Palindrome Linked List.<br>Memory Usage: 13.1 MB, less than 37.93% of C++ online submissions for Palindrome Linked List.</p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title>2.Add Two Numbers</title>
    <url>/posts/2010047615/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p>Example:</p>
<p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8<br>Explanation: 342 + 465 = 807.</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyhead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* p1 = dummyhead;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 || l2)&#123;</span><br><span class="line">            <span class="keyword">if</span> (l1)&#123;</span><br><span class="line">                x = l1 -&gt; val;</span><br><span class="line">                l1 = l1 -&gt; next;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                x = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (l2)&#123;</span><br><span class="line">                y = l2 -&gt; val;</span><br><span class="line">                l2 = l2 -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                y = <span class="number">0</span>;</span><br><span class="line">            p1 -&gt; next = <span class="keyword">new</span> ListNode((x + y + carry) % <span class="number">10</span>);</span><br><span class="line">            carry = x + y &gt;= <span class="number">10</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            p1 = p1 -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry)</span><br><span class="line">            p1 -&gt; next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> dummyhead -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title>141.Linked List Cycle</title>
    <url>/posts/3103972891/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given a linked list, determine if it has a cycle in it.</p>
<p>To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. </p>
<p>Example 1:<br>Input: head = [3,2,0,-4], pos = 1<br>Output: true<br>Explanation: There is a cycle in the linked list, where tail connects to the second node.</p>
<p>Example 2:<br>Input: head = [1,2], pos = 0<br>Output: true<br>Explanation: There is a cycle in the linked list, where tail connects to the first node.</p>
<p>Example 3:<br>Input: head = [1], pos = -1<br>Output: false<br>Explanation: There is no cycle in the linked list.</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>一开始完全没有思路，看了下题解才发现其实可以用set来判断有没有出现重复的node</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;ListNode*&gt; s;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.find(p) != s.end())&#123;</span><br><span class="line">                pos++;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s.insert(p);</span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 20 ms, faster than 17.13% of C++ online submissions for Linked List Cycle.<br>Memory Usage: 12.2 MB, less than 10.53% of C++ online submissions for Linked List Cycle.</p>
<h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><p>用两个指针，慢指针一次移动一步，快指针一次移动两步，然后判断快指针和慢指针会不会相等，如果相等则存在环。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast -&gt; next)&#123;</span><br><span class="line">            fast = fast -&gt; next -&gt; next;</span><br><span class="line">            slow = slow -&gt; next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 8 ms, faster than 97.20% of C++ online submissions for Linked List Cycle.<br>Memory Usage: 9.9 MB, less than 43.42% of C++ online submissions for Linked List Cycle.</p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title>142.Linked List CycleII</title>
    <url>/posts/3693154351/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p>
<p>To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.</p>
<p>Note: Do not modify the linked list.</p>
<p>Example 1:<br>Input: head = [3,2,0,-4], pos = 1<br>Output: tail connects to node index 1<br>Explanation: There is a cycle in the linked list, where tail connects to the second node.</p>
<p>Example 2:<br>Input: head = [1,2], pos = 0<br>Output: tail connects to node index 0<br>Explanation: There is a cycle in the linked list, where tail connects to the first node.</p>
<p>Example 3:<br>Input: head = [1], pos = -1<br>Output: no cycle<br>Explanation: There is no cycle in the linked list.</p>
<p>Follow-up:<br>Can you solve it without using extra space?</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>和上一题类似，使用set的方法比较容易想到。用一个set来记录已经遍历过的node，如果发现了有重复的，那么这个node就是环开始的地方。</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;ListNode*&gt; s;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.find(p) != s.end())</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            s.insert(p);</span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><p>现在还不太理解<br><a href="https://leetcode.com/problems/linked-list-cycle-ii/discuss/44781/Concise-O(n)-solution-by-using-C%2B%2B-with-Detailed-Alogrithm-Description" target="_blank" rel="noopener">https://leetcode.com/problems/linked-list-cycle-ii/discuss/44781/Concise-O(n)-solution-by-using-C%2B%2B-with-Detailed-Alogrithm-Description</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>medium</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title>384.Shuffle an Array</title>
    <url>/posts/2829300232/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Shuffle a set of numbers without duplicates.</p>
<p>Example:<br>// Init an array with set 1, 2, and 3.<br>int[] nums = {1,2,3};<br>Solution solution = new Solution(nums);</p>
<p>// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.<br>solution.shuffle();</p>
<p>// Resets the array back to its original configuration [1,2,3].<br>solution.reset();</p>
<p>// Returns the random shuffling of array [1,2,3].<br>solution.shuffle();</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>看到这道题实在是没什么头绪，看了下题解，学习了一下数组打乱的一种常用的算法：Fisher-Yates shuffle 洗牌算法，找到一篇不错的介绍的文章：<a href="https://gaohaoyang.github.io/2016/10/16/shuffle-algorithm/" target="_blank" rel="noopener">https://gaohaoyang.github.io/2016/10/16/shuffle-algorithm/</a><br>算法的思路就是</p>
<ol>
<li>从0到i（i一开始为数组的大小减一）随机取一个数字</li>
<li>交换第k位的数字和在随机数位上的数字，i–</li>
<li>重复上面两步直到i等于0<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; original;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        original = nums;</span><br><span class="line">        <span class="keyword">this</span> -&gt; nums = nums;</span><br><span class="line">        n = nums.size();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Resets the array to its original configuration and return it. */</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; reset() &#123;</span><br><span class="line">        <span class="keyword">return</span> original;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns a random shuffling of the array. */</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; shuffle() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = rand() % (i + <span class="number">1</span>);</span><br><span class="line">            swap(nums[i], nums[tmp]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution* obj = new Solution(nums);</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_1 = obj-&gt;reset();</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_2 = obj-&gt;shuffle();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Runtime: 204 ms, faster than 77.11% of C++ online submissions for Shuffle an Array.<br>Memory Usage: 30.1 MB, less than 100.00% of C++ online submissions for Shuffle an Array.</p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>medium</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title>88.Merge Sorted Array</title>
    <url>/posts/1685248582/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.</p>
<p>Note:</p>
<p>The number of elements initialized in nums1 and nums2 are m and n respectively.<br>You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.<br>Example:</p>
<p>Input:<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6],       n = 3</p>
<p>Output: [1,2,2,3,5,6]</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>从nums1和nums2有数字的最后开始比较大小，将大的放到nums1的最后。</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> i = m + n <span class="number">-1</span>, j = m - <span class="number">1</span>, k = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span>  &amp;&amp; k &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[j] &gt; nums2[k])&#123;</span><br><span class="line">                nums1[i] = nums1[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                nums1[i] = nums2[k];</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= <span class="number">0</span> &amp;&amp; j &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(k &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                nums1[i--] = nums2[k--];</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>vector</tag>
      </tags>
  </entry>
  <entry>
    <title>58.Length of Last Word</title>
    <url>/posts/116524668/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word (last word means the last appearing word if we loop from left to right) in the string.<br>If the last word does not exist, return 0.</p>
<p>Note: A word is defined as a maximal substring consisting of non-space characters only.</p>
<p>Example:<br>Input: “Hello World”<br>Output: 5</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>想起了之前做过的一道题：<a href="https://yutouwd.github.io/posts/316802933/">#824</a>可以使用istringstream来对一个字符串进行空格分割。</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> tmp;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ss &gt;&gt; tmp)&#123;</span><br><span class="line">            len = tmp.size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 0 ms, faster than 100.00% of C++ online submissions for Length of Last Word.<br>Memory Usage: 9.3 MB, less than 5.55% of C++ online submissions for Length of Last Word.</p>
<p>还可以把string先反转过来，就不需要再使用while循环了。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        reverse(s.begin(), s.end());</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        ss &gt;&gt; res;</span><br><span class="line">        <span class="keyword">return</span> res.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>278.First Bad Version</title>
    <url>/posts/539789119/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.</p>
<p>Suppose you have n versions [1, 2, …, n] and you want to find out the first bad one, which causes all the following ones to be bad.</p>
<p>You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</p>
<p>Example:</p>
<p>Given n = 5, and version = 4 is the first bad version.</p>
<p>call isBadVersion(3) -&gt; false<br>call isBadVersion(5) -&gt; true<br>call isBadVersion(4) -&gt; true</p>
<p>Then 4 is the first bad version. </p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>可以用二分搜索来做。</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Forward declaration of isBadVersion API.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBadVersion</span><span class="params">(<span class="keyword">int</span> version)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> isBadVersion(<span class="number">1</span>) ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> upper = n, lower = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">bool</span> upper_bad = isBadVersion(upper);</span><br><span class="line">        <span class="keyword">bool</span> lower_bad = isBadVersion(lower);</span><br><span class="line">        <span class="keyword">bool</span> middle_bad;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> middle = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            middle = (upper + lower) / <span class="number">2</span>;</span><br><span class="line">            middle_bad = isBadVersion(middle);</span><br><span class="line">            <span class="keyword">if</span> (middle_bad == upper_bad)</span><br><span class="line">                upper = middle;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                lower = middle;</span><br><span class="line">        &#125; <span class="keyword">while</span>((upper - lower != <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (isBadVersion(lower))</span><br><span class="line">            <span class="keyword">return</span> lower;</span><br><span class="line">        <span class="keyword">return</span> upper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 4 ms, faster than 52.02% of C++ online submissions for First Bad Version.<br>Memory Usage: 8.2 MB, less than 48.48% of C++ online submissions for First Bad Version.</p>
<h1 id="高票解法"><a href="#高票解法" class="headerlink" title="高票解法"></a>高票解法</h1><p>代码还有可以优化的地方<br>比如可以通过下面这种方式来避免int型的溢出，并且可以不用使用long型。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> middle = lower + (upper - lower) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Forward declaration of isBadVersion API.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBadVersion</span><span class="params">(<span class="keyword">int</span> version)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> upper = n, lower = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lower &lt; upper)&#123;</span><br><span class="line">            <span class="keyword">int</span> middle = lower + (upper - lower) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (isBadVersion(middle))</span><br><span class="line">                upper = middle;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                lower = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lower;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>36Valid Sudoku</title>
    <url>/posts/2138873447/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:</p>
<p>Each row must contain the digits 1-9 without repetition.<br>Each column must contain the digits 1-9 without repetition.<br>Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.</p>
<p>A partially filled sudoku which is valid.</p>
<p>The Sudoku board could be partially filled, where empty cells are filled with the character ‘.’.</p>
<p>Example 1:<br>Input:<br>[<br>  [“5”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”],<br>  [“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”],<br>  [“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”],<br>  [“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”],<br>  [“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”],<br>  [“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”],<br>  [“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”],<br>  [“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”],<br>  [“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]<br>]<br>Output: true</p>
<p>Example 2:<br>Input:<br>[<br>  [“8”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”],<br>  [“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”],<br>  [“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”],<br>  [“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”],<br>  [“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”],<br>  [“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”],<br>  [“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”],<br>  [“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”],<br>  [“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]<br>]<br>Output: false<br>Explanation: Same as Example 1, except with the 5 in the top left corner being<br>    modified to 8. Since there are two 8’s in the top left 3x3 sub-box, it is invalid.</p>
<p>Note:<br>A Sudoku board (partially filled) could be valid but is not necessarily solvable.<br>Only the filled cells need to be validated according to the mentioned rules.<br>The given board contain only digits 1-9 and the character ‘.’.<br>The given board size is always 9x9.</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>判断一个数独是不是有效的，只要检查同一行同一列和同一个3x3的格子有没有重复的数字。</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">CheckValid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; vec)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (vec.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> i : vec)&#123;</span><br><span class="line">            count[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> iter = count.begin(); iter != count.end(); iter++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (iter -&gt; second &gt; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> validRow = <span class="literal">true</span>, validCol = <span class="literal">true</span>, validBlk = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//check row</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; check;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">'.'</span>)</span><br><span class="line">                    check.push_back(board[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">bool</span> tmp = CheckValid(check);</span><br><span class="line">            validRow = tmp &amp;&amp; validRow;</span><br><span class="line">            check.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//check column</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (board[j][i] != <span class="string">'.'</span>)</span><br><span class="line">                    check.push_back(board[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">bool</span> tmp = CheckValid(check);</span><br><span class="line">            validCol = tmp &amp;&amp; validCol;</span><br><span class="line">            check.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//check block</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i += <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j += <span class="number">3</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++)&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; <span class="number">3</span>; l++)&#123;</span><br><span class="line">                        <span class="keyword">if</span> (board[i+k][j+l] != <span class="string">'.'</span>)</span><br><span class="line">                            check.push_back(board[i+k][j+l]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">bool</span> tmp = CheckValid(check);</span><br><span class="line">                validBlk = tmp &amp;&amp; validBlk;</span><br><span class="line">                check.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> validRow &amp;&amp; validCol &amp;&amp; validBlk;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 24 ms, faster than 15.59% of C++ online submissions for Valid Sudoku.<br>Memory Usage: 11.9 MB, less than 20.51% of C++ online submissions for Valid Sudoku.</p>
<h1 id="高票解法"><a href="#高票解法" class="headerlink" title="高票解法"></a>高票解法</h1><p>速度很慢，还要看下高票解法是怎么做的。</p>
<h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h2><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><h1 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h1>]]></content>
      <categories>
        <category>leetcode</category>
        <category>medium</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>vector</tag>
      </tags>
  </entry>
  <entry>
    <title>8.String to Integer</title>
    <url>/posts/2689180698/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Implement atoi which converts a string to an integer.<br>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.<br>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.<br>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.<br>If no valid conversion could be performed, a zero value is returned.</p>
<p>Note:<br>Only the space character ‘ ‘ is considered as whitespace character.<br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.</p>
<p>Example 1:<br>Input: “42”<br>Output: 42</p>
<p>Example 2:<br>Input: “   -42”<br>Output: -42<br>Explanation: The first non-whitespace character is ‘-‘, which is the minus sign.<br>             Then take as many numerical digits as possible, which gets 42.</p>
<p>Example 3:<br>Input: “4193 with words”<br>Output: 4193<br>Explanation: Conversion stops at digit ‘3’ as the next character is not a numerical digit.</p>
<p>Example 4:<br>Input: “words and 987”<br>Output: 0<br>Explanation: The first non-whitespace character is ‘w’, which is not a numerical<br>             digit or a +/- sign. Therefore no valid conversion could be performed.</p>
<p>Example 5:<br>Input: “-91283472332”<br>Output: -2147483648<br>Explanation: The number “-91283472332” is out of the range of a 32-bit signed integer.<br>             Thefore INT_MIN (−231) is returned.</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>将一个字符串转化成数组，首先遇到空格要跳过，然后遇到的第一个+号和-号就是数字的符号。然后接下来的数字就是我们要的数字，后面有字符也可以，但是如果字符在数字前面先出现就不可以。并且要做int型的溢出检测，在之前一道题就遇到了<a href="https://yutouwd.github.io/posts/837075">https://yutouwd.github.io/posts/837075</a>，就是下一题哈哈哈哈哈。</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, n = str.size();</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (str[i] == <span class="string">' '</span>)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">'-'</span> || str[i] == <span class="string">'+'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == <span class="string">'-'</span>)</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ((i &lt; n) &amp;&amp; <span class="built_in">isdigit</span>(str[i]))&#123;</span><br><span class="line">            <span class="keyword">int</span> num = str[i] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span> (flag &amp;&amp; ((ans &gt; INT_MAX/<span class="number">10</span>) || (ans == INT_MAX/<span class="number">10</span> &amp;&amp; num &gt; <span class="number">7</span>))) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">            <span class="keyword">if</span> (!flag &amp;&amp; ((ans &gt; -INT_MIN/<span class="number">10</span>) || (ans == -INT_MIN/<span class="number">10</span> &amp;&amp; num &gt;= <span class="number">8</span>))) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">            ans = ans * <span class="number">10</span> + num;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> -ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 0 ms, faster than 100.00% of C++ online submissions for String to Integer (atoi).<br>Memory Usage: 8.4 MB, less than 91.04% of C++ online submissions for String to Integer (atoi).</p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>medium</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>200.Numbers of Island</title>
    <url>/posts/1693659293/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given a 2d grid map of ‘1’s (land) and ‘0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>
<p>Example 1:<br>Input:<br>11110<br>11010<br>11000<br>00000<br>Output: 1</p>
<p>Example 2:<br>Input:<br>11000<br>11000<br>00100<br>00011<br>Output: 3</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>用深度优先搜索</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eraseIsland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> i , <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size(), m = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i == n || j == m || grid[i][j] == <span class="string">'0'</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        grid[i][j] = <span class="string">'0'</span>;</span><br><span class="line">        eraseIsland(grid, i + <span class="number">1</span>, j);</span><br><span class="line">        eraseIsland(grid, i - <span class="number">1</span>, j);</span><br><span class="line">        eraseIsland(grid, i, j + <span class="number">1</span>);</span><br><span class="line">        eraseIsland(grid, i, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size(), m = grid[<span class="number">0</span>].size(), island = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    eraseIsland(grid, i, j);</span><br><span class="line">                    island++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> island;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>medium</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>vector</tag>
      </tags>
  </entry>
  <entry>
    <title>350.Intersection of Two Arrays II</title>
    <url>/posts/2444108763/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given two arrays, write a function to compute their intersection.</p>
<p>Example 1:<br>Input: nums1 = [1,2,2,1], nums2 = [2,2]<br>Output: [2,2]</p>
<p>Example 2:<br>Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br>Output: [4,9]</p>
<p>Note:<br>Each element in the result should appear as many times as it shows in both arrays.<br>The result can be in any order.</p>
<p>Follow up:<br>What if the given array is already sorted? How would you optimize your algorithm?<br>What if nums1’s size is small compared to nums2’s size? Which algorithm is better?<br>What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>统计两个数组重复的数字，如果一个数字在两个数组中都出现了2次，那么返回数组也要包括两个这个数组。还是用unordered_map来实现，统计第一个数组每个数字出现的次数，然后再遍历第二个数组，如果有重复的数字，那么就加到答案数组中，并且将map中的key值减1。</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersect(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums1)</span><br><span class="line">            count[i]++;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span> (count[i])&#123;</span><br><span class="line">                ans.push_back(i);</span><br><span class="line">                count[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 4 ms, faster than 99.18% of C++ online submissions for Intersection of Two Arrays II.<br>Memory Usage: 9.7 MB, less than 26.79% of C++ online submissions for Intersection of Two Arrays II.</p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>vector</tag>
        <tag>hashmap</tag>
      </tags>
  </entry>
  <entry>
    <title>349.Intersection of Two Arrays</title>
    <url>/posts/1952106908/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given two arrays, write a function to compute their intersection.</p>
<p>Example 1:<br>Input: nums1 = [1,2,2,1], nums2 = [2,2]<br>Output: [2]</p>
<p>Example 2:<br>Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br>Output: [9,4]</p>
<p>Note:<br>Each element in the result must be unique.<br>The result can be in any order.</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>统计两个数组重复出现的数字，返回的数组每个数字都是不重复。使用两个unordered_map来记录两个数组每个数字出现的次数，然后如果如果存在相同的就加到答案数组中。</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersection(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; count1;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; count2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums1)</span><br><span class="line">            count1[i]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums2)</span><br><span class="line">            count2[i]++;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : count1)&#123;</span><br><span class="line">            <span class="keyword">if</span> (count2.find(i.first) != count2.end())</span><br><span class="line">                ans.push_back(i.first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 4 ms, faster than 99.17% of C++ online submissions for Intersection of Two Arrays.<br>Memory Usage: 9.8 MB, less than 10.00% of C++ online submissions for Intersection of Two Arrays.</p>
<h1 id="高票解法"><a href="#高票解法" class="headerlink" title="高票解法"></a>高票解法</h1><p>看了下高票的解答，发现其实可以用set来实现。用set来记录第一个数组中出现的数字，然后在遍历第二个数组，如果有出现的话就加到答案数组中去，并把set中的erase掉。</p>
<h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersection(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; s(nums1.begin(), nums1.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.count(i))&#123;</span><br><span class="line">                ans.push_back(i);</span><br><span class="line">                s.erase(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 4 ms, faster than 99.17% of C++ online submissions for Intersection of Two Arrays.<br>Memory Usage: 9.4 MB, less than 50.00% of C++ online submissions for Intersection of Two Arrays.</p>
<h1 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h1><p>学习了set的用法，如果把一个数组统计到set中可以直接用将begin和end输入到set中就可以了。</p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>vector</tag>
        <tag>hashmap</tag>
      </tags>
  </entry>
  <entry>
    <title>101.Symmetic Tree</title>
    <url>/posts/1627979900/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<p>For example, this binary tree [1,2,2,3,4,4,3] is symmetric:</p>
<pre><code>1
</code></pre><p>   / \<br>  2   2<br> / \ / \<br>3  4 4  3</p>
<p>But the following [1,2,2,null,3,null,3] is not:</p>
<pre><code>1
</code></pre><p>   / \<br>  2   2<br>   \   \<br>   3    3</p>
<p>Note:<br>Bonus points if you could solve it both recursively and iteratively.</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>判断一个树是不是对称二叉树，可以使用两个队列，一个储存root左边的子树，一个储存root右边的子树。</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        TreeNode *left, *right;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q1, q2;</span><br><span class="line">        q1.push(root -&gt; left);</span><br><span class="line">        q2.push(root -&gt; right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!q1.empty() &amp;&amp; !q2.empty())&#123;</span><br><span class="line">            left = q1.front();</span><br><span class="line">            right = q2.front();</span><br><span class="line">            q1.pop();</span><br><span class="line">            q2.pop();</span><br><span class="line">            <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (left -&gt; val != right -&gt; val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            q1.push(left -&gt; left);</span><br><span class="line">            q2.push(right -&gt; right);</span><br><span class="line">            q1.push(left -&gt; right);</span><br><span class="line">            q2.push(right -&gt; left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 4 ms, faster than 84.31% of C++ online submissions for Symmetric Tree.<br>Memory Usage: 15 MB, less than 37.29% of C++ online submissions for Symmetric Tree.</p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>medium</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>98.Validate Binary Search Tree</title>
    <url>/posts/521402559/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given a binary tree, determine if it is a valid binary search tree (BST).</p>
<p>Assume a BST is defined as follows:</p>
<p>The left subtree of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than the node’s key.<br>Both the left and right subtrees must also be binary search trees.</p>
<p>Example 1:</p>
<pre><code>2
</code></pre><p>   / \<br>  1   3<br>Input: [2,1,3]<br>Output: true</p>
<p>Example 2:</p>
<pre><code>5
</code></pre><p>   / \<br>  1   4<br>     / \<br>    3   6<br>Input: [5,1,4,null,null,3,6]<br>Output: false<br>Explanation: The root node’s value is 5 but its right child’s value is 4.</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>一开始似乎理解错了题目的意思</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isBST(root, LONG_MIN, LONG_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBST</span><span class="params">(TreeNode* root, <span class="keyword">long</span> lower, <span class="keyword">long</span> upper)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (root -&gt; val &lt;= lower || root -&gt; val &gt;= upper) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> left, right;</span><br><span class="line">        left = isBST(root -&gt; left, lower, root -&gt; val);</span><br><span class="line">        right = isBST(root -&gt; right, root -&gt; val, upper);</span><br><span class="line">        <span class="keyword">return</span> left &amp;&amp; right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 4 ms, faster than 99.97% of C++ online submissions for Validate Binary Search Tree.<br>Memory Usage: 20.6 MB, less than 86.46% of C++ online submissions for Validate Binary Search Tree.</p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>Medium</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>102.Binary Tree Level Order Traversal</title>
    <url>/posts/3533375508/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p>
<p>For example:<br>Given binary tree [3,9,20,null,null,15,7],<br>    3<br>   / \<br>  9  20<br>    /  \<br>   15   7<br>return its level order traversal as:<br>[<br>  [3],<br>  [9,20],<br>  [15,7]<br>]</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>层次遍历，可以用104题中的双向队列来实现</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">deque</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push_back(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> n = q.size();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; answer;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                TreeNode* node = q.front();</span><br><span class="line">                q.pop_front();</span><br><span class="line">                answer.push_back(node -&gt; val);</span><br><span class="line">                <span class="keyword">if</span> (node -&gt; left) q.push_back(node -&gt; left);</span><br><span class="line">                <span class="keyword">if</span> (node -&gt; right) q.push_back(node -&gt; right);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(answer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 4 ms, faster than 93.52% of C++ online submissions for Binary Tree Level Order Traversal.<br>Memory Usage: 13.7 MB, less than 98.59% of C++ online submissions for Binary Tree Level Order Traversal.</p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>medium</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>104.Maximum Depth of Binary Tree</title>
    <url>/posts/282883092/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<p>Note: A leaf is a node with no children.</p>
<p>Example:</p>
<p>Given binary tree [3,9,20,null,null,15,7],</p>
<pre><code>3
</code></pre><p>   / \<br>  9  20<br>    /  \<br>   15   7<br>return its depth = 3.</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>可以用递归来实现深度优先的方法</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = maxDepth(root-&gt;left) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r = maxDepth(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> l &gt; r ? l : r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 16 ms, faster than 21.06% of C++ online submissions for Maximum Depth of Binary Tree.<br>Memory Usage: 19 MB, less than 100.00% of C++ online submissions for Maximum Depth of Binary Tree.</p>
<h1 id="堆栈实现DFS"><a href="#堆栈实现DFS" class="headerlink" title="堆栈实现DFS"></a>堆栈实现DFS</h1><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;pair&lt;TreeNode*, <span class="keyword">int</span>&gt;&gt; s;</span><br><span class="line">        <span class="keyword">int</span> deep = <span class="number">1</span>;</span><br><span class="line">        s.push(pair&lt;TreeNode*, <span class="keyword">int</span>&gt;(root, deep));</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            TreeNode* curNode = s.top().first;</span><br><span class="line">            <span class="keyword">int</span> curDeep = s.top().second;</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">if</span> (curNode)&#123;</span><br><span class="line">                deep = max(deep, curDeep);</span><br><span class="line">                s.push(pair&lt;TreeNode*, <span class="keyword">int</span>&gt;(curNode -&gt; left, curDeep+<span class="number">1</span>));</span><br><span class="line">                s.push(pair&lt;TreeNode*, <span class="keyword">int</span>&gt;(curNode -&gt; right, curDeep+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 8 ms, faster than 87.69% of C++ online submissions for Maximum Depth of Binary Tree.<br>Memory Usage: 19.2 MB, less than 90.11% of C++ online submissions for Maximum Depth of Binary Tree.</p>
<h1 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h1>]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>路径规划之D* Lite算法详解及实现</title>
    <url>/posts/346220552/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>D* Lite算法是一种增量启发式搜素算法，由Sven Koeing和Maxim Likhachev于2004年提出，是基于LPA* 和Dynamic SWSF-F的一种算法。D* Lite算法可以适用于地图未知、环境随时会发生变化的情况，在遇到新增加的障碍物时，可以利用先前搜索所获得的信息，而不需要完全重新规划路径。</p>
<a id="more"></a>
<h1 id="基础算法介绍"><a href="#基础算法介绍" class="headerlink" title="基础算法介绍"></a>基础算法介绍</h1><p>在介绍D* Lite之前先简单介绍下广度优先、最佳优先以及A* 算法。如果要在一个网格地图中找到两点之间的最短路径，很容易想到的广度优先算法和最佳优先算法。</p>
<p>这章用的图片都来自于这篇博客：<a href="https://paul.pub/a-star-algorithm/" target="_blank" rel="noopener">https://paul.pub/a-star-algorithm/</a>。这篇博客对A* 算法对介绍也非常详细。</p>
<h2 id="广度优先算法"><a href="#广度优先算法" class="headerlink" title="广度优先算法"></a>广度优先算法</h2><p>广度优先算法就是从一个点开始遍历周围的节点，逐步向外扩散，已经遍历过的就不用再遍历，直到找到了终点。就如下图所示：</p>
<img src="/posts/346220552/1.gif">
<p>广度优先算法的优点是一定可以找到两点间的最优路径，但是代价就是需要搜索的点非常多，速度会比较慢。</p>
<h2 id="最佳优先算法"><a href="#最佳优先算法" class="headerlink" title="最佳优先算法"></a>最佳优先算法</h2><p>最佳优先算法和广度优先算法不同，它需要使用一个优先队列，用每个点到终点到距离到估计值来判断一个点的优先级。首先先遍历起点周围的点，计算到终点的距离，距离越近优先级越高。之后就取出优先队列中优先级最高的点，再遍历它点周围节点加入优先队列。之后就不断重复这个过程，直到到达终点。和广度优先相比，最佳优先所需要搜索的点要少很多，如下图所示：</p>
<img src="/posts/346220552/2.gif">
<p>但最佳优先算法的缺点就是，当起点和终点有障碍物时，可能最佳优先算法找到的路径并不是最佳的路径：</p>
<img src="/posts/346220552/3.gif">
<h2 id="A-算法介绍"><a href="#A-算法介绍" class="headerlink" title="A*算法介绍"></a>A*算法介绍</h2><p>A* 算法就是把广度优先算法和最佳优先算法的优点所结合起来了。A* 算法通过下面的公式来评估一个点的优先级：</p>
<p>$$ f(n)=g(n)+h(n) $$</p>
<p>其中：</p>
<ul>
<li>f(n)是节点n的优先级评估值，f(n)值越小的点优先值越高。</li>
<li>g(n)是节点到起点到实际代价。</li>
<li>h(n)是启发函数，是节点n到终点到估计值。</li>
</ul>
<p>A* 算法还需要使用两个集合来表示代遍历的节点和已经遍历的节点，通常成为open list和close list，其中open list需要使用优先队列。A* 算法首先从起点开始，计算周围的点的优先值并且加入优先队列。之后开始从优先队列中选取优先值最小的点，将其加入close list并且同样计算周围的点的优先值加入优先队列（close list中的点就不需要再计算了）。不断重复这个过程直到搜索到终点算法就结束，返回路径。</p>
<p>A* 算法的公式中，g(n)使得算法能选取相对来说走得更少的点，h(n)能使算法优先选择离终点更近的点（不考虑障碍物的情况，因为使估计值）。</p>
<h1 id="D-Lite算法详解"><a href="#D-Lite算法详解" class="headerlink" title="D* Lite算法详解"></a>D* Lite算法详解</h1><p>D* Lite是一种增量启发式算法。启发式和A*类似，同样有一个启发函数，不过因为D* Lite是从终点向起点搜索，所以对应的启发函数h(n)也变成了节点n到起点的估计值。增量式算法之前找了好久也没有找到相关的定义，后来无意中在西瓜书里面看到了一段对增量学习对定义：</p>
<blockquote>
<p>增量学习是指在学得模型后，再接收到训练样例时，仅需根据新样例对模型进行更新，不必重新训练整个模型，并且先前学得的有效信息不会被冲掉。</p>
</blockquote>
<p>D* Lite算法就是这样，当检测到了新的障碍物，算法不需要完全重新规划路径，可以利用之前搜索所获得的信息，来找到一条可以避开障碍物的路径。</p>
<h2 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h2><p>在介绍D* Lite的具体算法之前，先介绍几个它所引入的概念。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>一个A*算法的介绍博客：<br><a href="https://paul.pub/a-star-algorithm/" target="_blank" rel="noopener">https://paul.pub/a-star-algorithm/</a><br>D*算法介绍博客：<br><a href="https://blog.csdn.net/lqzdreamer/article/details/85055569" target="_blank" rel="noopener">https://blog.csdn.net/lqzdreamer/article/details/85055569</a><br>D* Lite算法介绍博客：<br><a href="https://blog.csdn.net/lqzdreamer/article/details/85108310" target="_blank" rel="noopener">https://blog.csdn.net/lqzdreamer/article/details/85108310</a></p>
]]></content>
      <categories>
        <category>路径规划</category>
      </categories>
      <tags>
        <tag>路径规划</tag>
      </tags>
  </entry>
  <entry>
    <title>215.Kth Largest Element in an Array</title>
    <url>/posts/2993655736/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p>
<p>Example 1:<br>Input: [3,2,1,5,6,4] and k = 2<br>Output: 5</p>
<p>Example 2:<br>Input: [3,2,3,1,2,4,5,5,6] and k = 4<br>Output: 4</p>
<p>Note:<br>You may assume k is always valid, 1 ≤ k ≤ array’s length.</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>可以想把数组排序，然后在返回第k大的数字就可以了</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">return</span> nums[nums.size() - k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 12 ms, faster than 77.71% of C++ online submissions for Kth Largest Element in an Array.<br>Memory Usage: 9.2 MB, less than 89.39% of C++ online submissions for Kth Largest Element in an Array.</p>
<h1 id="高票解法"><a href="#高票解法" class="headerlink" title="高票解法"></a>高票解法</h1><p>C++中排序的时间复杂度为O(NlogN)，如果使用优先队列，对于插入一个大小为k的优先队列插入N次，时间复杂度为O(Nlogk)也可以使用C++中的priority_queue优先队列，默认是大顶堆。</p>
<h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>&gt; pq(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            pq.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pq.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 8 ms, faster than 97.45% of C++ online submissions for Kth Largest Element in an Array.<br>Memory Usage: 9.5 MB, less than 40.91% of C++ online submissions for Kth Largest Element in an Array.</p>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>还可以进一步优化一下，使堆的大小最多保持在k<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; pq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span> (pq.size() == k)&#123;</span><br><span class="line">                <span class="keyword">if</span> (num &gt; pq.top())&#123;</span><br><span class="line">                    pq.pop();</span><br><span class="line">                    pq.push(num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pq.push(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pq.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Runtime: 8 ms, faster than 97.45% of C++ online submissions for Kth Largest Element in an Array.<br>Memory Usage: 9.5 MB, less than 33.33% of C++ online submissions for Kth Largest Element in an Array.</p>
<h1 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h1><p>学习了C++中priority_queue的使用</p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>medium</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>vector</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>169.Majority Element</title>
    <url>/posts/3720766983/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>
<p>Example 1:<br>Input: [3,2,3]<br>Output: 3</p>
<p>Example 2:<br>Input: [2,2,1,1,1,2,2]<br>Output: 2</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>按照分治法的标签找到的题目，但是感觉可以直接用一个map来记录每个数字出现的次数，然后再遍历map找到出现最多的次数就可以了。</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums)</span><br><span class="line">            count[i]++;</span><br><span class="line">        <span class="keyword">int</span> maxNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : count)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i.second &gt; maxCount)&#123;</span><br><span class="line">                maxCount = i.second;</span><br><span class="line">                maxNum = i.first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 20 ms, faster than 77.92% of C++ online submissions for Majority Element.<br>Memory Usage: 11.2 MB, less than 48.48% of C++ online submissions for Majority Element.</p>
<h1 id="高票解法"><a href="#高票解法" class="headerlink" title="高票解法"></a>高票解法</h1><p>在讨论区看到了一个更加简洁的方法，在统计的同时进行判断，如果大于数组的长度的二分之一就一定是众数了。</p>
<h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; counter;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span> (++counter[num] &gt; nums.size() / <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>50.Pow(x,n)</title>
    <url>/posts/2356977837/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Implement pow(x, n), which calculates x raised to the power n (xn).</p>
<p>Example 1:<br>Input: 2.00000, 10<br>Output: 1024.00000</p>
<p>Example 2:<br>Input: 2.10000, 3<br>Output: 9.26100</p>
<p>Example 3:<br>Input: 2.00000, -2<br>Output: 0.25000<br>Explanation: 2-2 = 1/22 = 1/4 = 0.25</p>
<p>Note:<br>-100.0 &lt; x &lt; 100.0<br>n is a 32-bit signed integer, within the range [−2^31, 2^31 − 1]</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>计算一个数的幂，最先想到的方法就是用循环的方法，但是要考虑好当n=0或者n小于0的情况。</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">double</span> ans = x;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)&#123;</span><br><span class="line">            x = <span class="number">1</span>/x;</span><br><span class="line">            ans = x;</span><br><span class="line">            n = -n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            ans *= x;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当输入为：<br>0.00001<br>2147483647<br>会超出时间限制</p>
<h1 id="高票解法"><a href="#高票解法" class="headerlink" title="高票解法"></a>高票解法</h1><p>于是去看了看官方解法</p>
<h2 id="快速幂算法-递归"><a href="#快速幂算法-递归" class="headerlink" title="快速幂算法-递归"></a>快速幂算法-递归</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">fastPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> half = fastPow(x, n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> half * half;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> half * half * x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">if</span> (N &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            N = -N;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fastPow(x, N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>思路就是，当我们知道了x^n时，我们就可以快速的求出x^2n，而不需要在将x乘n次</p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>medium</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>27.Remove Element</title>
    <url>/posts/2601079941/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given an array nums and a value val, remove all instances of that value in-place and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
<p>Example 1:<br>Given nums = [3,2,2,3], val = 3,</p>
<p>Your function should return length = 2, with the first two elements of nums being 2.</p>
<p>It doesn’t matter what you leave beyond the returned length.</p>
<p>Example 2:<br>Given nums = [0,1,2,2,3,0,4,2], val = 2,</p>
<p>Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.</p>
<p>Note that the order of those five elements can be arbitrary.</p>
<p>It doesn’t matter what values are set beyond the returned length.<br>Clarification:</p>
<p>Confused why the returned value is an integer but your answer is an array?</p>
<p>Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.</p>
<p>Internally you can think of this:</p>
<p>// nums is passed in by reference. (i.e., without making a copy)<br>int len = removeElement(nums, val);</p>
<p>// any modification to nums in your function would be known by the caller.<br>// using the length returned by your function, it prints the first len elements.<br>for (int i = 0; i &lt; len; i++) {<br>    print(nums[i]);<br>}</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.size(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] != val)&#123;</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>vector</tag>
      </tags>
  </entry>
  <entry>
    <title>48.Rotate Image</title>
    <url>/posts/1761982827/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>You are given an n x n 2D matrix representing an image.</p>
<p>Rotate the image by 90 degrees (clockwise).</p>
<p>Note:</p>
<p>You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.</p>
<p>Example 1:</p>
<p>Given input matrix =<br>[<br>  [1,2,3],<br>  [4,5,6],<br>  [7,8,9]<br>],</p>
<p>rotate the input matrix in-place such that it becomes:<br>[<br>  [7,4,1],<br>  [8,5,2],<br>  [9,6,3]<br>]<br>Example 2:</p>
<p>Given input matrix =<br>[<br>  [ 5, 1, 9,11],<br>  [ 2, 4, 8,10],<br>  [13, 3, 6, 7],<br>  [15,14,12,16]<br>], </p>
<p>rotate the input matrix in-place such that it becomes:<br>[<br>  [15,13, 2, 5],<br>  [14, 3, 4, 1],<br>  [12, 6, 8, 9],<br>  [16, 7,10,11]<br>]</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>其实把要转换的次数以及每次转换对应的位置找到规律就可以了</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n = matrix.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n - i - <span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[n-j<span class="number">-1</span>][i];</span><br><span class="line">                matrix[n-j<span class="number">-1</span>][i] = matrix[n-i<span class="number">-1</span>][n-j<span class="number">-1</span>];</span><br><span class="line">                matrix[n-i<span class="number">-1</span>][n-j<span class="number">-1</span>] = matrix[j][n-i<span class="number">-1</span>];</span><br><span class="line">                matrix[j][n-i<span class="number">-1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 0 ms, faster than 100.00% of C++ online submissions for Rotate Image.<br>Memory Usage: 9 MB, less than 87.81% of C++ online submissions for Rotate Image.</p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>medium</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>vector</tag>
      </tags>
  </entry>
  <entry>
    <title>20.Valid Parentheses</title>
    <url>/posts/4278894845/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.</p>
<p>An input string is valid if:</p>
<p>Open brackets must be closed by the same type of brackets.<br>Open brackets must be closed in the correct order.<br>Note that an empty string is also considered valid.</p>
<p>Example 1:<br>Input: “()”<br>Output: true</p>
<p>Example 2:<br>Input: “()[]{}”<br>Output: true</p>
<p>Example 3:<br>Input: “(]”<br>Output: false</p>
<p>Example 4:<br>Input: “([)]”<br>Output: false</p>
<p>Example 5:<br>Input: “{[]}”<br>Output: true</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>用一个string来做堆来储存左边的括号，如果遇到右边的括号就判断堆顶的左边括号和右边括号匹不匹配。</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.size() % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">string</span> tmp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'('</span> || s[i] == <span class="string">'['</span> || s[i] == <span class="string">'&#123;'</span>)</span><br><span class="line">                tmp.push_back(s[i]);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> ((s[i] == <span class="string">')'</span> &amp;&amp; *(tmp.end() - <span class="number">1</span>) == <span class="string">'('</span>) || (s[i] == <span class="string">'&#125;'</span> &amp;&amp; *(tmp.end() - <span class="number">1</span>) == <span class="string">'&#123;'</span>) || (s[i] == <span class="string">']'</span> &amp;&amp; *(tmp.end() - <span class="number">1</span>) == <span class="string">'['</span>))</span><br><span class="line">                    tmp.pop_back();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmp.size() != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 0 ms, faster than 100.00% of C++ online submissions for Valid Parentheses.<br>Memory Usage: 8.3 MB, less than 97.67% of C++ online submissions for Valid<br>虽然可以完成任务可以代码长了点</p>
<h1 id="高票解法"><a href="#高票解法" class="headerlink" title="高票解法"></a>高票解法</h1><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; paren;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> &amp; c : s)&#123;</span><br><span class="line">            <span class="keyword">switch</span>(c) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'['</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'&#123;'</span>: paren.push(c); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">')'</span>: <span class="keyword">if</span>(paren.empty() || paren.top() != <span class="string">'('</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="keyword">else</span> paren.pop(); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">']'</span>: <span class="keyword">if</span>(paren.empty() || paren.top() != <span class="string">'['</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="keyword">else</span> paren.pop(); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'&#125;'</span>: <span class="keyword">if</span>(paren.empty() || paren.top() != <span class="string">'&#123;'</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="keyword">else</span> paren.pop(); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> paren.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>用switch case和stack就能整洁很多</p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>118.Pascal Triangle</title>
    <url>/posts/281994477/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given a non-negative integer numRows, generate the first numRows of Pascal’s triangle.</p>
<p>In Pascal’s triangle, each number is the sum of the two numbers directly above it.</p>
<p>Example:<br>Input: 5<br>Output:<br>[<br>     [1],<br>    [1,1],<br>   [1,2,1],<br>  [1,3,3,1],<br> [1,4,6,4,1]<br>]</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><p>这题比较简单<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        ans.resize(numRows);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows; i++)&#123;</span><br><span class="line">            ans[i].resize(i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i + <span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span> || j == i)</span><br><span class="line">                    ans[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    ans[i][j] = ans[i<span class="number">-1</span>][j<span class="number">-1</span>] + ans[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Runtime: 4 ms, faster than 60.45% of C++ online submissions for Pascal’s Triangle.<br>Memory Usage: 8.8 MB, less than 88.89% of C++ online submissions for Pascal’s Triangle.</p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>198.House Robber</title>
    <url>/posts/2797751844/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p>
<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p>
<p>Example 1:<br>Input: [1,2,3,1]<br>Output: 4<br>Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).<br>             Total amount you can rob = 1 + 3 = 4.</p>
<p>Example 2:<br>Input: [2,7,9,3,1]<br>Output: 12<br>Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).<br>             Total amount you can rob = 2 + 9 + 1 = 12.</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>感觉和最大子集有点类似，可以用动态规划的方法。</p>
<ol>
<li>当n等于1时，只能抢第一个房子。</li>
<li>当n等于2时，这时候抢两个房子中最大的max(n1,n2)。</li>
<li>当n等于3时，如果就要抢max(n1+n3,n2)<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">2</span>) <span class="keyword">return</span> max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(nums.size(), <span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            dp[i] = max(dp[i<span class="number">-2</span>] + nums[i], dp[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.size() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Runtime: 0 ms, faster than 100.00% of C++ online submissions for House Robber.<br>Memory Usage: 8.5 MB, less than 92.45% of C++ online submissions for House Robber.</p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>125.Valid Palindrome</title>
    <url>/posts/2448753357/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p>
<p>Note: For the purpose of this problem, we define empty string as valid palindrome.</p>
<p>Example 1:<br>Input: “A man, a plan, a canal: Panama”<br>Output: true</p>
<p>Example 2:<br>Input: “race a car”<br>Output: false</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>题目其实挺简单的，就是实现的时候怎么能到简洁优雅，也是看了一个答案才知道。</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = s.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">while</span> ((i &lt; j) &amp;&amp; !(<span class="built_in">isdigit</span>(s[i]) || <span class="built_in">isalpha</span>(s[i] )))&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> ((i &lt; j) &amp;&amp; !(<span class="built_in">isdigit</span>(s[j]) || <span class="built_in">isalpha</span>(s[j] )))&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">toupper</span>(s[i]) != <span class="built_in">toupper</span>(s[j]))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            i++, j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 4 ms, faster than 99.21% of C++ online submissions for Valid Palindrome.<br>Memory Usage: 9.5 MB, less than 36.74% of C++ online submissions for Valid Palindrome.</p>
<h1 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h1><p>C++ 大小写转化、判断是不是字母的方法</p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>123.Best Time to Buy and Sell III</title>
    <url>/posts/974687170/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Say you have an array for which the ith element is the price of a given stock on day i.<br>Design an algorithm to find the maximum profit. You may complete at most two transactions.</p>
<p>Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p>
<p>Example 1:<br>Input: [3,3,5,0,0,3,1,4]<br>Output: 6<br>Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.<br>             Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.</p>
<p>Example 2:<br>Input: [1,2,3,4,5]<br>Output: 4<br>Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.<br>             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are<br>             engaging multiple transactions at the same time. You must sell before buying again.</p>
<p>Example 3:<br>Input: [7,6,4,3,1]<br>Output: 0<br>Explanation: In this case, no transaction is done, i.e. max profit = 0.</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>也在面试的时候遇到了这道题，后悔没有把这一系列的题目做完。现在再做的话还是做不出来😂</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><h1 id="高票解法"><a href="#高票解法" class="headerlink" title="高票解法"></a>高票解法</h1><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h2><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><h1 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h1>]]></content>
      <categories>
        <category>leetcode</category>
        <category>hard</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>122.Best Time to Buy and Sell Stock II</title>
    <url>/posts/473611493/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).</p>
<p>Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p>
<p>Example 1:<br>Input: [7,1,5,3,6,4]<br>Output: 7<br>Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.<br>             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.</p>
<p>Example 2:<br>Input: [1,2,3,4,5]<br>Output: 4<br>Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.<br>             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are<br>             engaging multiple transactions at the same time. You must sell before buying again.</p>
<p>Example 3:<br>Input: [7,6,4,3,1]<br>Output: 0<br>Explanation: In this case, no transaction is done, i.e. max profit = 0.</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>可以使用一种投机的方法，只要第二天的股价大于第一天，就可以在第一天买入，在第二天卖出，因为一定会有收益</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.size() &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.size() - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &lt; prices[i+<span class="number">1</span>])</span><br><span class="line">                profit += prices[i+<span class="number">1</span>] - prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 4 ms, faster than 98.15% of C++ online submissions for Best Time to Buy and Sell Stock II.<br>Memory Usage: 9.6 MB, less than 68.25% of C++ online submissions for Best Time to Buy and Sell Stock II.</p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>824.Goat Latin</title>
    <url>/posts/316802933/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>A sentence S is given, composed of words separated by spaces. Each word consists of lowercase and uppercase letters only.</p>
<p>We would like to convert the sentence to “Goat Latin” (a made-up language similar to Pig Latin.)</p>
<p>The rules of Goat Latin are as follows:</p>
<p>If a word begins with a vowel (a, e, i, o, or u), append “ma” to the end of the word.<br>For example, the word ‘apple’ becomes ‘applema’.</p>
<p>If a word begins with a consonant (i.e. not a vowel), remove the first letter and append it to the end, then add “ma”.<br>For example, the word “goat” becomes “oatgma”.</p>
<p>Add one letter ‘a’ to the end of each word per its word index in the sentence, starting with 1.<br>For example, the first word gets “a” added to the end, the second word gets “aa” added to the end and so on.<br>Return the final sentence representing the conversion from S to Goat Latin. </p>
<p>Example 1:<br>Input: “I speak Goat Latin”<br>Output: “Imaa peaksmaaa oatGmaaaa atinLmaaaaa”</p>
<p>Example 2:<br>Input: “The quick brown fox jumped over the lazy dog”<br>Output: “heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa”</p>
<p>Notes:</p>
<p>S contains only uppercase, lowercase and spaces. Exactly one space between each word.<br>1 &lt;= S.length &lt;= 150.</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>题目其实挺好理解的，就是要在每个单词的后面加上ma，如果单词是辅音开头的就要把辅音字母放到最后再加ma。之前做了一题是要把每个单词分开，一直没找到比较快的方法，这次还是看评论学会了一种方法。之后其实就很简单了。</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">toGoatLatin</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; vowel = &#123;<span class="string">'a'</span>,<span class="string">'e'</span>,<span class="string">'i'</span>,<span class="string">'o'</span>,<span class="string">'u'</span>,<span class="string">'A'</span>,<span class="string">'E'</span>,<span class="string">'I'</span>,<span class="string">'O'</span>,<span class="string">'U'</span>&#125;;</span><br><span class="line">        <span class="built_in">string</span> ma = <span class="string">"maa"</span>;</span><br><span class="line">        <span class="built_in">string</span> tmp, re;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">ss</span><span class="params">(S)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(ss &gt;&gt; tmp)&#123;</span><br><span class="line">            <span class="built_in">string</span> ans;</span><br><span class="line">            <span class="keyword">if</span> (vowel.find(tmp[<span class="number">0</span>]) != vowel.end())&#123;</span><br><span class="line">                ans = tmp;</span><br><span class="line">                ans += ma;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ans = tmp.substr(<span class="number">1</span>,tmp.size() - <span class="number">1</span>);</span><br><span class="line">                ans += tmp[<span class="number">0</span>];</span><br><span class="line">                ans += ma;</span><br><span class="line">            &#125;</span><br><span class="line">            re += ans;</span><br><span class="line">            re += <span class="string">' '</span>;</span><br><span class="line">            ma += <span class="string">'a'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re.substr(<span class="number">0</span>,re.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 0 ms, faster than 100.00% of C++ online submissions for Goat Latin.<br>Memory Usage: 9.1 MB, less than 71.43% of C++ online submissions for Goat Latin.</p>
<h1 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h1><p>C++将string按空格分开可以用istringstream，在sstream头文件中。</p>
<p>set的用法，set和map的区别是set只有一个值，而map有key和value两个值。</p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>223.Rectangle Area</title>
    <url>/posts/3099514846/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Find the total area covered by two rectilinear rectangles in a 2D plane.</p>
<p>Each rectangle is defined by its bottom left corner and top right corner as shown in the figure.</p>
<p>Rectangle Area</p>
<p>Example:<br>Input: A = -3, B = 0, C = 3, D = 4, E = 0, F = -1, G = 9, H = 2<br>Output: 45</p>
<p>Note:<br>Assume that the total area is never beyond the maximum possible value of int.</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>其实就是和求IOU类似，但是C++会遇到各种边界问题…提示中说总面积不会超过int的最大值，但是如果没有减去相交的面积时可能会超过int的最大值。</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">computeArea</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B, <span class="keyword">int</span> C, <span class="keyword">int</span> D, <span class="keyword">int</span> E, <span class="keyword">int</span> F, <span class="keyword">int</span> G, <span class="keyword">int</span> H)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果直接用max(0,...)后面两个相减的可能会超出int的下界</span></span><br><span class="line">        <span class="keyword">int</span> x = min(C,G) &gt; max(A,E) ? min(C,G) - max(A,E) : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = min(D,H) &gt; max(B,F) ? min(D,H) - max(B,F) : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (C - A) * (D -B) - x * y + (G -E) * (H - F);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>206.Reverse Linked List</title>
    <url>/posts/2829474180/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Reverse a singly linked list.</p>
<p>Example:<br>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
<p>Follow up:<br>A linked list can be reversed either iteratively or recursively. Could you implement both?</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>将一个链表反转过来</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur)&#123;</span><br><span class="line">            ListNode* tmp = cur -&gt; next;</span><br><span class="line">            cur -&gt; next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 8 ms, faster than 77.15% of C++ online submissions for Reverse Linked List.<br>Memory Usage: 9.3 MB, less than 77.10% of C++ online submissions for Reverse Linked List.</p>
<h1 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h1><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head -&gt; next == <span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* p = reverseList(head -&gt; next);</span><br><span class="line">        head -&gt; next -&gt; next = head;</span><br><span class="line">        head -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 8 ms, faster than 77.11% of C++ online submissions for Reverse Linked List.<br>Memory Usage: 9.2 MB, less than 96.95% of C++ online submissions for Reverse Linked </p>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>递归法感觉挺难理解的</p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title>326.Power of Three</title>
    <url>/posts/2084194376/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given an integer, write a function to determine if it is a power of three.</p>
<p>Example 1:<br>Input: 27<br>Output: true</p>
<p>Example 2:<br>Input: 0<br>Output: false</p>
<p>Example 3:<br>Input: 9<br>Output: true</p>
<p>Example 4:<br>Input: 45<br>Output: false</p>
<p>Follow up:<br>Could you do it without using any loop / recursion?</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>求一个数是不是3的幂，想到的方法是将一个数不断的求模并且将n除以3，如果模不等于零就停止，判断n是不是等于1，如果不等于1那就不是3的幂。</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (mod == <span class="number">0</span>)&#123;</span><br><span class="line">            mod = n % <span class="number">3</span>;</span><br><span class="line">            n /= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> &amp;&amp; mod == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 16 ms, faster than 67.53% of C++ online submissions for Power of Three.<br>Memory Usage: 8.1 MB, less than 90.48% of C++ online submissions for Power of Three.</p>
<p>题目中还要求程序中不使用循环或者递归</p>
<h1 id="高票解法"><a href="#高票解法" class="headerlink" title="高票解法"></a>高票解法</h1><p>主要有两种方法<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span> Max3PowerInt = <span class="number">1162261467</span>; <span class="comment">// 3^19, 3^20 = 3486784401 &gt; MaxInt32</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span> MaxInt32 = <span class="number">2147483647</span>; <span class="comment">// 2^31 - 1</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span> || n &gt; Max3PowerInt) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> Max3PowerInt % n == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>利用int的上限，求最大的3的幂，它除以n的模为零就说明n是3的幂</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">double</span> x = <span class="built_in">log10</span>(n) / <span class="built_in">log10</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">floor</span>(x) == x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过换底公式来判断。</p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>204.Count Primes</title>
    <url>/posts/828591771/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Count the number of prime numbers less than a non-negative number, n.</p>
<p>Example:<br>Input: 10<br>Output: 4</p>
<p>Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>之前就做过了一题求质数的方法，记下了一种较为快速的求质数的方法。首先任何一个数都可以表示为一下形式：/{6n,6n+1,6n+2,6n+3,6n+4,6n+5/}(n=0,1,2…)，很显然6n,6n+2,6n+4能被2整除，6n+3能被3整除，所以只用考虑6n+1和6n+5的数。再加上一个数最大的因数小于等于它的开方，有了这几个条件就可以大大减少计算量了。</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> n &gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">6</span> != <span class="number">1</span> &amp;&amp; n % <span class="number">6</span> != <span class="number">5</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">sqrt</span> = <span class="built_in">std</span>::<span class="built_in">sqrt</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &lt;= <span class="built_in">sqrt</span>; i+=<span class="number">6</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span> || n % (i+<span class="number">2</span>) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrime(i))</span><br><span class="line">                count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 168 ms, faster than 24.06% of C++ online submissions for Count Primes.<br>Memory Usage: 8.2 MB, less than 95.83% of C++ online submissions for Count Primes.</p>
<p>但是速度还是有点点的慢呀</p>
<h1 id="高票解法"><a href="#高票解法" class="headerlink" title="高票解法"></a>高票解法</h1><p>厄拉多筛选法：声明一个长度为n的数组。从2开始，将2的倍数都标记出来；然后将3的倍数也都标记出来；因为4已经是2的倍数了，所以是4的倍数也应定是2的倍数，就不考虑4的倍数。然后在把5的倍数标记出来…</p>
<h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; isPrime(n, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrime[i])&#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i+i; j &lt; n; j += i)&#123;</span><br><span class="line">                    isPrime[j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 80 ms, faster than 42.73% of C++ online submissions for Count Primes.<br>Memory Usage: 8.7 MB, less than 54.17% of C++ online submissions for Count Primes.</p>
<p>时间快了很多，但是看其他更快的也基本都是用这种方法的，不知道是不是测试用例更新了。</p>
<h2 id="继续优化"><a href="#继续优化" class="headerlink" title="继续优化"></a>继续优化</h2><p>又看到了一个更快的方法，使用了一些tricks<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; isPrime(n, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">int</span> count = n - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> rt = <span class="built_in">sqrt</span>(n); <span class="comment">// 只用计算到sqrt(n)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= rt; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrime[i])&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i*i; j &lt; n; j += i)&#123;  <span class="comment">// 从i*i开始而不是i+i，因为比如说6，已经被2筛选过了</span></span><br><span class="line">                    <span class="keyword">if</span> (isPrime[j])&#123;</span><br><span class="line">                        isPrime[j] = <span class="literal">false</span>;</span><br><span class="line">                        count--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Runtime: 64 ms, faster than 59.63% of C++ online submissions for Count Primes.<br>Memory Usage: 8.8 MB, less than 45.83% of C++ online submissions for Count Primes.</p>
<h1 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h1><p>学习了求质数较为快速的方法</p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>53.Maximum Subarray</title>
    <url>/posts/1411250823/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p>
<p>Example:<br>Input: [-2,1,-3,4,-1,2,1,-5,4],<br>Output: 6<br>Explanation: [4,-1,2,1] has the largest sum = 6.</p>
<p>Follow up:<br>If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>今天笔试的时候遇到的一个题目，就想到了用暴力的做法，就是遍历数组两遍，把所有的可能都算出来</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxSum = INT_MIN;</span><br><span class="line">        <span class="keyword">int</span> curSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            curSum = nums[i];</span><br><span class="line">            <span class="keyword">if</span> (curSum &gt; maxSum)</span><br><span class="line">                maxSum = curSum;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.size(); j++)&#123;</span><br><span class="line">                curSum += nums[j];</span><br><span class="line">                <span class="keyword">if</span> (curSum &gt; maxSum)&#123;</span><br><span class="line">                    maxSum = curSum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 308 ms, faster than 5.00% of C++ online submissions for Maximum Subarray.<br>Memory Usage: 9.2 MB, less than 99.02% of C++ online submissions for Maximum Subarray.</p>
<p>速度真的好慢。。。因为时间复杂度是O(n^2)吧</p>
<h1 id="一次遍历"><a href="#一次遍历" class="headerlink" title="一次遍历"></a>一次遍历</h1><p>看到一个<a href="https://leetcode-cn.com/problems/maximum-subarray/solution/bao-li-qiu-jie-by-pandawakaka/" target="_blank" rel="noopener">python实现</a>的一次遍历的方法，转成了C++代码。不得不说C++都没有大于两个max的函数，还要自己写一个，比python麻烦多了。不过后来发现其实这个程序里不需要用到四个参数的max，自己也把程序简化了一下，去除了一些多余的判断。</p>
<p>思路就是使用两个变量，一个记录当前子集的和，另一个记录最大子集的和。然后在遍历的过程中判断如果当前的子集（不包括当前值）是不是大于0：如果大于零就把当前值加到当前子集的和中，然后判断是当前子集大还是最大子集大，并更新最大子集；如果是小于等于零就可以认为这个子集对于构成一个最大和的子集是没有贡献的，然后就从当前值开始构成当前子集，并继续开始判断。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//使用两个变量，一个记录最大的和，一个记录当前的和</span></span><br><span class="line">        <span class="keyword">int</span> curSum = nums[<span class="number">0</span>]; <span class="comment">// 当前子集的和</span></span><br><span class="line">        <span class="keyword">int</span> maxSum = curSum;    <span class="comment">// 最大的和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="comment">// 如果当前子集为正值，就把当前值加到当前子集中，再判断是之前的最大子集大还是当前子集大</span></span><br><span class="line">            <span class="keyword">if</span> (curSum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                curSum += nums[i];</span><br><span class="line">                maxSum = max(maxSum, curSum + nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果当前子集为0或者负数那么从当前值开始往后求后面的子集</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                maxSum = max(maxSum, nums[i]);</span><br><span class="line">                curSum = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 4 ms, faster than 98.58% of C++ online submissions for Maximum Subarray.<br>Memory Usage: 9.1 MB, less than 100.00% of C++ online submissions for Maximum Subarray.</p>
<p>只用4ms了，快了真的不是一点半点，算法时间复杂度O(n)，空间复杂度O(1)。</p>
<h1 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h1><p>分治法其实一开始没有看懂，直到自己用手把测试用例推了一遍才大概明白。思路还是将一个问题分解成更小的问题，只不过这里要分解成3个问题，因为如果直接将数组分成两个数组会遇到最大子集在两个数组中间的情况，所以要取一个middle=(start+end)/2，分解成[start,middle-1]，[middle+1,end]，然后还要考虑middle的问题，就要将middle往两遍遍历，求出向左和向右的最大子集，方法和一次遍历的类似。最后比较左边数组、右边数组和middle加上向左和向右的最大子集（小于零就加零）的最大值。</p>
<p>这样看来这道题目使用分治法比其他方法要麻烦挺多的，时间复杂度也是O(nlogn)，思路也相对更难理解，主要是因为不能直接分解成两个问题吧。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 边界条件</span></span><br><span class="line">        <span class="keyword">if</span> (start == end) <span class="keyword">return</span> nums[start];</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left_max = <span class="number">0</span>, right_max = <span class="number">0</span>, ml = <span class="number">0</span>, mr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        left_max = find(nums, start, middle - <span class="number">1</span>);</span><br><span class="line">        right_max = find(nums, middle + <span class="number">1</span>, end);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// middle to left</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = middle - <span class="number">1</span>, sum = <span class="number">0</span>; i &gt;= start; i--)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (ml &lt; sum) ml = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// middle to right</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = middle + <span class="number">1</span>, sum = <span class="number">0</span>; i &lt;= end; i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (mr &lt; sum) mr = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max(max(left_max, right_max), ml + mr + nums[middle]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>看了一个视频感觉豁然开朗，<a href="https://www.bilibili.com/video/av38722679" target="_blank" rel="noopener">https://www.bilibili.com/video/av38722679</a><br>要用动态规划要具备两个性质，重叠子问题和最优子问题</p>
<ul>
<li>最优子问题：如果一个问题的最优解包含了其中子问题的最优解，那么称其有最优子结构</li>
<li>重叠子问题：当解决一个问题时，往往依赖其更小规模的子问题的解，甚至依赖与若干个规模更小的子问题的解。</li>
</ul>
<p>对于这道题目来说：</p>
<ul>
<li>最优子问题：很明显对于最大的子集最优子问题是符合的</li>
<li>重叠子问题：对于当前的解，需要用到之前子集求出来的解（感觉有点解释不清楚）</li>
</ul>
<p>状态转移方程为： dp[i] = max(nums[i], nums[i] + dp[i])</p>
<p>以[-2,1,-3,4,-1,2,1,-5,4]为例子</p>
<ol>
<li>[-2]的最大子集显然就是它自己本身，所以dp=[-2]</li>
<li>[-2,1]的子集有{-2,-1,1}，最大子集就是1了，dp=[-2,1]</li>
<li>对于[-2,1,-3]，上一个子集的解是1，加上-3为-2，dp=[-2,1,-2]<br>…</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(nums.size(), <span class="number">0</span>); </span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]; </span><br><span class="line">        <span class="keyword">int</span> max = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            dp[i] = nums[i] &gt; nums[i] + dp[i - <span class="number">1</span>] ? nums[i] : nums[i] + dp[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt; max) max = dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 4 ms, faster than 98.60% of C++ online submissions for Maximum Subarray.<br>Memory Usage: 9.5 MB, less than 9.80% of C++ online submissions for Maximum Subarray.</p>
<p>感觉思路其实和一次遍历是差不多的，不同的是需要一个同样大小的数组来记录之前的解。</p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>Easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>动态规划</tag>
        <tag>分治法</tag>
      </tags>
  </entry>
  <entry>
    <title>412.Fizz Buzz</title>
    <url>/posts/807358486/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Write a program that outputs the string representation of numbers from 1 to n.</p>
<p>But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.</p>
<p>Example:</p>
<p>n = 15,</p>
<p>Return:<br>[<br>    “1”,<br>    “2”,<br>    “Fizz”,<br>    “4”,<br>    “Buzz”,<br>    “Fizz”,<br>    “7”,<br>    “8”,<br>    “Fizz”,<br>    “Buzz”,<br>    “11”,<br>    “Fizz”,<br>    “13”,<br>    “14”,<br>    “FizzBuzz”<br>]</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题比较简单</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; fizzBuzz(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; output;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> mod3 = i % <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">int</span> mod5 = i % <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">if</span> (mod5 == <span class="number">0</span> &amp;&amp; mod3 == <span class="number">0</span>)</span><br><span class="line">                output.push_back(<span class="string">"FizzBuzz"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mod3 == <span class="number">0</span> &amp;&amp; mod5 != <span class="number">0</span>)</span><br><span class="line">                output.push_back(<span class="string">"Fizz"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mod5 == <span class="number">0</span> &amp;&amp; mod3 != <span class="number">0</span>)</span><br><span class="line">                output.push_back(<span class="string">"Buzz"</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                output.push_back(to_string(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>21.Merge Two Sorted Lists</title>
    <url>/posts/2341614181/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
<p>Example:</p>
<p>Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* tail = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)&#123;</span><br><span class="line">            <span class="keyword">if</span> (l1 -&gt; val &lt; l2 -&gt; val)&#123;</span><br><span class="line">                tail -&gt; next = l1;</span><br><span class="line">                l1 = l1 -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                tail -&gt; next = l2;</span><br><span class="line">                l2 = l2 -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        tail -&gt; next = l1 ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> head -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title>19.Remove Nth Node From End of List</title>
    <url>/posts/1165746741/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given a linked list, remove the n-th node from the end of list and return its head.</p>
<p>Example:</p>
<p>Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</p>
<p>After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.<br>Note:</p>
<p>Given n will always be valid.</p>
<p>Follow up:</p>
<p>Could you do this in one pass?</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>想到的办法是先遍历一次链表，求出链表的长度，再删除对应的节点。</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !(head -&gt; next)) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//如果链表为空或者只有一个节点返回NULL</span></span><br><span class="line">        <span class="comment">/*先求链表长度*/</span></span><br><span class="line">        ListNode* p1 = head;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p1)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            p1 = p1 -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*删除节点*/</span></span><br><span class="line">        ListNode* p2 = head; <span class="comment">//用于删除节点</span></span><br><span class="line">        ListNode* p3 = head; <span class="comment">//用于记录head位置，最后返回</span></span><br><span class="line">        <span class="keyword">if</span> (len == n)&#123;       <span class="comment">//如果是删除第一个节点</span></span><br><span class="line">            p2 = p2 -&gt; next;</span><br><span class="line">            <span class="keyword">return</span> p2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - n - <span class="number">1</span>; i++) <span class="comment">//移动到要删除的节点之前</span></span><br><span class="line">            p2 = p2 -&gt; next;</span><br><span class="line">        p2 -&gt; next = p2 -&gt; next -&gt; next;</span><br><span class="line">        <span class="keyword">return</span> p3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 4 ms, faster than 85.75% of C++ online submissions for Remove Nth Node From End of List.<br>Memory Usage: 8.6 MB, less than 67.11% of C++ online submissions for Remove Nth Node From End of List.</p>
<h1 id="高票解法"><a href="#高票解法" class="headerlink" title="高票解法"></a>高票解法</h1><p>看了下题解才知道怎么只用一次遍历就能完成，思路是：<br>设置两个指针p和q，当p指向链表的末尾NULL时，p和q之间间隔的元素为n，删掉p下一个节点就可以了</p>
<h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !(head -&gt; next)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummyHead -&gt; next = head;</span><br><span class="line">        ListNode* first = dummyHead;</span><br><span class="line">        ListNode* second= dummyHead;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++)</span><br><span class="line">            first = first -&gt; next;</span><br><span class="line">        <span class="keyword">while</span>(first)&#123;</span><br><span class="line">            first = first -&gt; next;</span><br><span class="line">            second= second-&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        second -&gt; next = second -&gt; next -&gt; next;</span><br><span class="line">        <span class="keyword">return</span> dummyHead -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>其实不太理解为什么都要用到dummyHead，它的next指向head。但如果不用的话就会出现各种边界问题。看了下一个动画图解和评论，好像有点理解了。因为要找的是待删除结点的前一个节点，而头结点没有前一个节点，所以设置了一个虚拟节点</p>
<h1 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h1><p>链表的节点删除</p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>medium</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title>237.Delete Node in a List</title>
    <url>/posts/3749239881/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.</p>
<p>Given linked list – head = [4,5,1,9], which looks like following:</p>
<p>Example 1:<br>Input: head = [4,5,1,9], node = 5<br>Output: [4,1,9]<br>Explanation: You are given the second node with value 5, the linked list should become 4 -&gt; 1 -&gt; 9 after calling your function.</p>
<p>Example 2:<br>Input: head = [4,5,1,9], node = 1<br>Output: [4,5,9]<br>Explanation: You are given the third node with value 1, the linked list should become 4 -&gt; 5 -&gt; 9 after calling your function.</p>
<p>Note:<br>The linked list will have at least two elements.<br>All of the nodes’ values will be unique.<br>The given node will not be the tail and it will always be a valid node of the linked list.<br>Do not return anything from your function.</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><p>这道题真的很奇怪，没有给链表的head直接给了当前的节点🤔<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        *node = *(node-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title>242.Valid Anagram</title>
    <url>/posts/544546071/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given two strings s and t , write a function to determine if t is an anagram of s.</p>
<p>Example 1:<br>Input: s = “anagram”, t = “nagaram”<br>Output: true</p>
<p>Example 2:<br>Input: s = “rat”, t = “car”<br>Output: false</p>
<p>Note:<br>You may assume the string contains only lowercase alphabets.</p>
<p>Follow up:<br>What if the inputs contain unicode characters? How would you adapt your solution to such case?</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>题目要求判断两个字符串是否是以同样的字符组成</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.size() != t.size()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m1,m2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : s) m1[i]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : t) m2[i]++;</span><br><span class="line">        <span class="keyword">if</span> (m1 == m2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 16 ms, faster than 55.14% of C++ online submissions for Valid Anagram.<br>Memory Usage: 9.5 MB, less than 74.63% of C++ online submissions for Valid Anagram.</p>
<h1 id="高票解法"><a href="#高票解法" class="headerlink" title="高票解法"></a>高票解法</h1><p>因为只有小写的字母，所以可以用一个数组来统计每个字符出现的次数</p>
<h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> counts[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; </span><br><span class="line">            counts[s[i] - <span class="string">'a'</span>]++;</span><br><span class="line">            counts[t[i] - <span class="string">'a'</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (counts[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 8 ms, faster than 97.83% of C++ online submissions for Valid Anagram.<br>Memory Usage: 9.6 MB, less than 55.22% of C++ online submissions for Valid Anagram.</p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hashmap</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>387.First Unique Character in a String</title>
    <url>/posts/1245254830/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1.</p>
<p>Examples:</p>
<p>s = “leetcode”<br>return 0.</p>
<p>s = “loveleetcode”,<br>return 2.<br>Note: You may assume the string contain only lowercase letters.</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>题目要求判断一个字符串中第一个不重复的字符，可以用一个map来统计字符串中字符出现的次数，然后再找到第一个出现次数为1的字符就可以了</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; chara;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> i : s) chara[i]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (chara[s[i]] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 52 ms, faster than 59.91% of C++ online submissions for First Unique Character in a String.<br>Memory Usage: 12.9 MB, less than 68.75% of C++ online submissions for First Unique Character in a String.</p>
<h1 id="高票解法"><a href="#高票解法" class="headerlink" title="高票解法"></a>高票解法</h1><p>用时稍微有些长，因为要遍历字符串两遍，如果字符串很长就要用时很久，看到一个只用遍历一变的方法，就是第一次遍历的时候同时也要储存字符的位置，然后之后直接遍历map找到出现一次且位置最前的字符就可以了。</p>
<h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; m;</span><br><span class="line">        <span class="keyword">int</span> idx = s.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">            m[s[i]].first++;</span><br><span class="line">            m[s[i]].second = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;p : m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.second.first == <span class="number">1</span>) idx = min(idx, p.second.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> idx == s.size() ? <span class="number">-1</span> : idx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 68 ms, faster than 31.77% of C++ online submissions for First Unique Character in a String.<br>Memory Usage: 13.3 MB, less than 10.94% of C++ online submissions for First Unique Character in a String.</p>
<p>用时好像还更久一点。。。</p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hashmap</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>344.Reverse String</title>
    <url>/posts/3640092658/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Write a function that reverses a string. The input string is given as an array of characters char[].</p>
<p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
<p>You may assume all the characters consist of printable ascii characters.</p>
<p>Example 1:</p>
<p>Input: [“h”,”e”,”l”,”l”,”o”]<br>Output: [“o”,”l”,”l”,”e”,”h”]<br>Example 2:</p>
<p>Input: [“H”,”a”,”n”,”n”,”a”,”h”]<br>Output: [“h”,”a”,”n”,”n”,”a”,”H”]</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            swap(s[i++],s[j--]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>70.Climbing Stairs</title>
    <url>/posts/1665362949/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>You are climbing a stair case. It takes n steps to reach to the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
<p>Note: Given n will be a positive integer.</p>
<p>Example 1:<br>Input: 2<br>Output: 2<br>Explanation: There are two ways to climb to the top.</p>
<ol>
<li>1 step + 1 step</li>
<li>2 steps</li>
</ol>
<p>Example 2:<br>Input: 3<br>Output: 3<br>Explanation: There are three ways to climb to the top.</p>
<ol>
<li>1 step + 1 step + 1 step</li>
<li>1 step + 2 steps</li>
<li>2 steps + 1 step</li>
</ol>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><a href="http://blog.ihuxu.com/divide-and-conquer-backtracking-and-dynamic-programming-from-a-frog-jumping-out/" target="_blank" rel="noopener">之前看过一篇博客讲分治法就见到了这道题目</a>。分治法就是Divide and Conquer，流程有三步：</p>
<blockquote>
<ul>
<li>分解（Divide）将大规模的问题分解成若干个规模更小但形式相同的子问题<ul>
<li>解决（Conquer）如果当前问题的规模足够小，并可以直接解决的话，那么直接解决并返回解。否则，继续进行分解并递归求解分解后的子问题。</li>
<li>合并（Merge）将各个子问题合并，最终形成原问题的解。</li>
</ul>
</li>
</ul>
</blockquote>
<p>通常可以通过递归的方式来实现分治法，就这道问题而言，如果当前在走第n步，那么可以把问题分解为走n-1步（当前走1个台阶）和n-2步（当前走两个台阶），即f(n)=f(n-1)+f(n-2)，当n等于1或2的时候，就分别只有1或2种走法了。</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> climbStairs(n - <span class="number">1</span>) + climbStairs(n - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span> &amp;&amp; n &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是如果用递归的话，会在n等于44的时候超出时间限制</p>
<h1 id="高票解法"><a href="#高票解法" class="headerlink" title="高票解法"></a>高票解法</h1><p>也可以用for循环来完成这个问题</p>
<h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = now;</span><br><span class="line">            now += pre;</span><br><span class="line">            pre = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>其实思路也很简单，就是用pre记录n-1的方法数，now来记录n的方法数，然后每个for循环中都更新now和pre。当进行到n+1的时候，now就等于之前的now加上pre。</p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>分治法</tag>
      </tags>
  </entry>
  <entry>
    <title>914.X of a Kind in a Deck of Cards</title>
    <url>/posts/4098248511/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>In a deck of cards, each card has an integer written on it.</p>
<p>Return true if and only if you can choose X &gt;= 2 such that it is possible to split the entire deck into 1 or more groups of cards, where:</p>
<p>Each group has exactly X cards.<br>All the cards in each group have the same integer.</p>
<p>Example 1:<br>Input: [1,2,3,4,4,3,2,1]<br>Output: true<br>Explanation: Possible partition [1,1],[2,2],[3,3],[4,4]</p>
<p>Example 2:<br>Input: [1,1,1,2,2,2,3,3]<br>Output: false<br>Explanation: No possible partition.</p>
<p>Example 3:<br>Input: [1]<br>Output: false<br>Explanation: No possible partition.</p>
<p>Example 4:<br>Input: [1,1]<br>Output: true<br>Explanation: Possible partition [1,1]</p>
<p>Example 5:<br>Input: [1,1,2,2,2,2]<br>Output: true<br>Explanation: Possible partition [1,1],[2,2],[2,2]</p>
<p>Note:</p>
<p>1 &lt;= deck.length &lt;= 10000<br>0 &lt;= deck[i] &lt; 10000</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>题目要求判断一个数组能否按要求分组，分组要求如下：</p>
<ul>
<li>一个组里的数字的数值必须相等</li>
<li>每个组的size必须相等，并且大于等于2</li>
</ul>
<p>我的想法是统计一下数组里面每一个数出现的频率统计一下，如果频率都能被一个数（大于等于2）整除就可以。所以用map来实现比较方便。</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasGroupsSizeX</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; deck)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; numOfcard;</span><br><span class="line">        <span class="comment">/*先将每个数字出现的次数统计一下*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deck.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (numOfcard.find(deck[i]) != numOfcard.end())&#123; <span class="comment">//已经有数据</span></span><br><span class="line">                numOfcard[deck[i]]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">//还没有添加数据</span></span><br><span class="line">                numOfcard.insert(&#123;deck[i],<span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (numOfcard.size() == <span class="number">1</span> &amp;&amp; deck.size() != <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">/*判断出现的数字的频率能不能被同一个数字整除*/</span></span><br><span class="line">        <span class="keyword">int</span> maxX = deck.size() / numOfcard.size() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxX; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> zeroMod = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> iter = numOfcard.begin(); iter != numOfcard.end(); iter++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (iter-&gt;second % i == <span class="number">0</span>)</span><br><span class="line">                    zeroMod++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (zeroMod == numOfcard.size())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 16 ms, faster than 80.38% of C++ online submissions for X of a Kind in a Deck of Cards.<br>Memory Usage: 9.8 MB, less than 52.47% of C++ online submissions for X of a Kind in a Deck of Cards.</p>
<p>提交了几次，用时不是特别稳定大概就16～24ms之间吧。<br>后来测试了一下，发现map里默认的value是0，所以就可以省略去第一个for里面的if和else判断了<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasGroupsSizeX</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; deck)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; numOfcard;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deck.size(); i++)</span><br><span class="line">            numOfcard[deck[i]]++;</span><br><span class="line">        <span class="keyword">if</span> (numOfcard.size() == <span class="number">1</span> &amp;&amp; deck.size() != <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> maxX = deck.size() / numOfcard.size() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxX; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> zeroMod = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> iter = numOfcard.begin(); iter != numOfcard.end(); iter++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (iter-&gt;second % i == <span class="number">0</span>)</span><br><span class="line">                    zeroMod++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (zeroMod == numOfcard.size())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="高票解法"><a href="#高票解法" class="headerlink" title="高票解法"></a>高票解法</h1><p>看了下高票的解法，发现居然能用5行就能实现的，太厉害了吧。</p>
<h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasGroupsSizeX</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; deck)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; count;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : deck) count[i]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : count) res = __gcd(i.second, res);</span><br><span class="line">    <span class="keyword">return</span> res &gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>首先就是for (int i : deck)这种用法就没怎么见过了，测试了一下<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; testcase = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : testcase)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以依次输出testcase里面的数字，感觉用法和iterator差不多只不过iterator返回的是地址，这个可以直接返回元素。好像是C++11的用法，参考：<a href="https://en.cppreference.com/w/cpp/language/range-for" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/language/range-for</a>第一个for循环，就将deck数组里面数字出现的频率统计了一遍，并放到map里。</p>
<p>接下来第二个for循环遍历整个map，然后就一个求最大公约数的过程，__gcd就是可以求两个数的最大公约数，这个for循环就求了每个数字出现的频率的最大公约数。</p>
<h1 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h1><p>继续学习了map的用法，可以用两三句就可以把一个数组里出现的数据的频率统计了：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; count;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : <span class="built_in">array</span>)</span><br><span class="line">    count[i]++;</span><br></pre></td></tr></table></figure></p>
<p>还学了一种更简单的for循环的用法。</p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hashmap</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>283.Move Zeroes</title>
    <url>/posts/2335896064/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</p>
<p>Example:</p>
<p>Input: [0,1,0,3,12]<br>Output: [1,3,12,0,0]<br>Note:</p>
<p>You must do this in-place without making a copy of the array.<br>Minimize the total number of operations.</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题比较简单，直接从后往前遍历数组，如果元素等于零就删除并在数组的最后push一个0.</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                nums.erase(nums.begin()+i);</span><br><span class="line">                nums.push_back(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 16 ms, faster than 70.00% of C++ online submissions for Move Zeroes.<br>Memory Usage: 9.4 MB, less than 69.36% of C++ online submissions for Move Zeroes.</p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>vector</tag>
      </tags>
  </entry>
  <entry>
    <title>66.Plus One</title>
    <url>/posts/353015550/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given a non-empty array of digits representing a non-negative integer, plus one to the integer.</p>
<p>The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.</p>
<p>You may assume the integer does not contain any leading zero, except the number 0 itself.</p>
<p>Example 1:</p>
<p>Input: [1,2,3]<br>Output: [1,2,4]<br>Explanation: The array represents the integer 123.<br>Example 2:</p>
<p>Input: [4,3,2,1]<br>Output: [4,3,2,2]<br>Explanation: The array represents the integer 4321.</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>可以先设计一个函数，将输入值加一并且返回是否有进位，有进位就返回true，没有返回false。然后在主程序里写个for循环，如果一直有进位就循环继续，没有进位的话就跳出循环。最后还要判断下数组的第一位是不是零，如果是零就在数组的开头插入一个1。</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">addOneCarry</span><span class="params">(<span class="keyword">int</span>&amp; digit)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (digit == <span class="number">9</span>)&#123;</span><br><span class="line">            digit = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            digit++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; plusOne(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = digits.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (addOneCarry(digits[i]))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (digits[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">            digits.insert(digits.begin(),<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 4 ms, faster than 73.90% of C++ online submissions for Plus One.<br>Memory Usage: 8.6 MB, less than 49.35% of C++ online submissions for Plus One.</p>
<h1 id="高票解法"><a href="#高票解法" class="headerlink" title="高票解法"></a>高票解法</h1><p>看了看评论，发现其实可以简化一下程序的。直接判断当前位是不是9就可以了。</p>
<h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; plusOne(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = digits.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (digits[i] == <span class="number">9</span>)</span><br><span class="line">                digits[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                digits[i]++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (digits[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">            digits.insert(digits.begin(),<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 4 ms, faster than 73.90% of C++ online submissions for Plus One.<br>Memory Usage: 8.5 MB, less than 69.58% of C++ online submissions for Plus One.</p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>vector</tag>
      </tags>
  </entry>
  <entry>
    <title>136.Single Number</title>
    <url>/posts/1550415194/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given a non-empty array of integers, every element appears twice except for one. Find that single one.</p>
<p>Note:</p>
<p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<p>Example 1:<br>Input: [2,2,1]<br>Output: 1</p>
<p>Example 2:<br>Input: [4,1,2,1,2]<br>Output: 4</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>可以先将数组进行排序，再和两边的数字进行比较，如果都不一样就是要找的的数字。</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="number">0</span>] != nums[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size()<span class="number">-1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != nums[i+<span class="number">1</span>] &amp;&amp; nums[i] != nums[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[nums.size()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 20 ms, faster than 37.49% of C++ online submissions for Single Number.<br>Memory Usage: 9.7 MB, less than 53.92% of C++ online submissions for Single Number.</p>
<h1 id="高票解法"><a href="#高票解法" class="headerlink" title="高票解法"></a>高票解法</h1><p>速度还是稍微慢了点的，看看高票的解法吧～<br>看到有好巧妙的方法，比如用按位异或的方法。因为相同的数字异或是等于0的，并且一个数和0异或的结果还是这个数，异或也符合交换律。所以将数组里的数全部按位异或，最后就可以得到只出现一次的数字了。</p>
<h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">            num ^= nums[i];</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 16 ms, faster than 73.30% of C++ online submissions for Single Number.<br>Memory Usage: 9.6 MB, less than 82.15% of C++ online submissions for Single Number.</p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>vector</tag>
      </tags>
  </entry>
  <entry>
    <title>217.Contains Duplicate</title>
    <url>/posts/679636703/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given an array of integers, find if the array contains any duplicates.</p>
<p>Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p>
<p>Example 1:<br>Input: [1,2,3,1]<br>Output: true</p>
<p>Example 2:<br>Input: [1,2,3,4]<br>Output: false</p>
<p>Example 3:<br>Input: [1,1,1,3,3,4,3,2,4,2]<br>Output: true</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>题目要求判断一个数组里面有没有重复的数字，最先想到的办法当然是暴力法，就把数组里全部的数字都比较一遍，如果有重复就返回true，没有就返回false</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; nums.size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] == nums[j])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是发现会超出时间限制。</p>
<h1 id="高票解法"><a href="#高票解法" class="headerlink" title="高票解法"></a>高票解法</h1><p>高票解法中用了set，只用1行就可以了。或者可以用sort函数先将数组进行排序，然后排序后如果有重复的数字一定会在相邻的位置。</p>
<h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums.size() &gt; <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;(nums.begin(),nums.end()).size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 52 ms, faster than 29.45% of C++ online submissions for Contains Duplicate.<br>Memory Usage: 18.1 MB, less than 5.06% of C++ online submissions for Contains </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size()<span class="number">-1</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i+<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 24 ms, faster than 99.01% of C++ online submissions for Contains Duplicate.<br>Memory Usage: 11.2 MB, less than 95.37% of C++ online submissions for Contains Duplicate.</p>
<h1 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h1><p>学习C++中set和sort的用法</p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>vector</tag>
      </tags>
  </entry>
  <entry>
    <title>189.Rotate Array</title>
    <url>/posts/4112301143/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given an array, rotate the array to the right by k steps, where k is non-negative.</p>
<p>Example 1:<br>Input: [1,2,3,4,5,6,7] and k = 3<br>Output: [5,6,7,1,2,3,4]<br>Explanation:<br>rotate 1 steps to the right: [7,1,2,3,4,5,6]<br>rotate 2 steps to the right: [6,7,1,2,3,4,5]<br>rotate 3 steps to the right: [5,6,7,1,2,3,4]</p>
<p>Example 2:<br>Input: [-1,-100,3,99] and k = 2<br>Output: [3,99,-1,-100]<br>Explanation:<br>rotate 1 steps to the right: [99,-1,-100,3]<br>rotate 2 steps to the right: [3,99,-1,-100]<br>Note:</p>
<ul>
<li>Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.</li>
<li>Could you do it in-place with O(1) extra space?</li>
</ul>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>题目要求讲一个数组向右移动几位，最先想到的办法就是另外声明一个数组，然后将位移后的数组存到新数组里，最后再将新数组复制到旧数组里。</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp(n);</span><br><span class="line">        k = k % n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + k;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= n)</span><br><span class="line">                j = j - n;</span><br><span class="line">            tmp[j] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        nums = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 16 ms, faster than 88.16% of C++ online submissions for Rotate Array.<br>Memory Usage: 9.6 MB, less than 50.79% of C++ online submissions for Rotate Array.</p>
<h1 id="优化方法1"><a href="#优化方法1" class="headerlink" title="优化方法1"></a>优化方法1</h1><p>提示说能不能用O(1)的方法，想了一下没有想到条件要怎么设置。看了下讨论区，有一种环状替换的方法</p>
<h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; nums.size()) k = k % nums.size();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;  <span class="comment">//count 用来记录一共移动了多少次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; count &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = i; <span class="comment">//curr用于记录起始位置</span></span><br><span class="line">            <span class="keyword">int</span> prev = nums[i]; <span class="comment">//prev用于记录替换前的数值</span></span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> next = (curr + k) % nums.size(); <span class="comment">//next为将要替换的位置</span></span><br><span class="line">                <span class="keyword">int</span> tmp = nums[next];</span><br><span class="line">                nums[next] = prev;</span><br><span class="line">                prev = tmp;</span><br><span class="line">                curr = next;  <span class="comment">//更新当前位置</span></span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">while</span> (i != curr); <span class="comment">//如果没有回到起点的话就一直继续下去</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="优化方法2"><a href="#优化方法2" class="headerlink" title="优化方法2"></a>优化方法2</h1><p>还看到一个用reverse的方法，只需要4行代码…</p>
<h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; nums.size()) k = k % nums.size();</span><br><span class="line">        reverse(nums.begin(),nums.end());</span><br><span class="line">        reverse(nums.begin(),nums.begin() + k);</span><br><span class="line">        reverse(nums.begin() + k,nums.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>vector</tag>
      </tags>
  </entry>
  <entry>
    <title>Best Time to Buy and Sell Stock</title>
    <url>/posts/3220033831/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<p>Note that you cannot sell a stock before you buy one.</p>
<p>Example 1:<br>Input: [7,1,5,3,6,4]<br>Output: 5<br>Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.<br>             Not 7-1 = 6, as selling price needs to be larger than buying price.</p>
<p>Example 2:<br>Input: [7,6,4,3,1]<br>Output: 0<br>Explanation: In this case, no transaction is done, i.e. max profit = 0.</p>
<h2 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h2><p>一看题目觉得还是挺简单的，可以用最简单的穷举法<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.size();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; prices.size();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (prices[j] - prices[i] &gt; max)</span><br><span class="line">                    max = prices[j] - prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Runtime: 828 ms, faster than 8.10% of C++ online submissions for Best Time to Buy and Sell Stock.<br>Memory Usage: 9.6 MB, less than 14.91% of C++ online submissions for Best Time to Buy and Sell Stock.</p>
<hr>
<p>但是结果并不是很理想，时间用的太多了。有两个循环时间复杂读为O(n^2)</p>
<h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><p>看评论有一种方法，其实只用记录之前都最小值和最大利润即可。如果当前值小于最小值就更新最小值，否则计算当前值与最小值都差值是不是大于最大利润。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">if</span> (prices.size() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxPro = <span class="number">0</span>, minPrice = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] - minPrice &gt; maxPro)</span><br><span class="line">                maxPro = prices[i] - minPrice;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (prices[i] &lt; minPrice)</span><br><span class="line">                minPrice = prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxPro;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 8 ms, faster than 78.13% of C++ online submissions for Best Time to Buy and Sell Stock.<br>Memory Usage: 9.5 MB, less than 60.83% of C++ online submissions for Best Time to Buy and Sell Stock.</p>
<hr>
<p>速度一下就快了很多～</p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>26.Remove Duplicates From Sorted Array</title>
    <url>/posts/3324950855/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
<p>Example 1:<br>Given nums = [1,1,2],<br>Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.<br>It doesn’t matter what you leave beyond the returned length.</p>
<p>Example 2:<br>Given nums = [0,0,1,1,1,2,2,3,3,4],<br>Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.<br>It doesn’t matter what values are set beyond the returned length.</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>要将一个排列好的数组去掉重复的元素，然后返回长度。感觉挺简单的，可以用一个iterator和当前值对比，如果一样就erase掉，不一样就更新当前值，最后返回数组size。</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = nums.begin()+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(iter != nums.end())&#123;</span><br><span class="line">            <span class="keyword">if</span> (*iter == tmp)&#123;</span><br><span class="line">                iter = nums.erase(iter);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                tmp = *iter;</span><br><span class="line">                iter++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 152 ms, faster than 19.92% of C++ online submissions for Remove Duplicates from Sorted Array.<br>Memory Usage: 9.9 MB, less than 63.90% of C++ online submissions for Remove Duplicates from Sorted Array.</p>
<h1 id="代码改进"><a href="#代码改进" class="headerlink" title="代码改进"></a>代码改进</h1><p>发现速度比较慢，看了下评论发现题目中没有要求要删掉重复的元素，erase的过程导致时间比较长。所以可以用将不重复的元素放到数组的前面。<br>It doesn’t matter what values are set beyond the returned length.</p>
<h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">1</span>; <span class="comment">//用于记录有多少不重复的数字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == tmp)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                tmp = nums[i];</span><br><span class="line">                nums[j] = nums[i];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 20 ms, faster than 94.92% of C++ online submissions for Remove Duplicates from Sorted Array.<br>Memory Usage: 10 MB, less than 21.43% of C++ online submissions for Remove Duplicates from Sorted Array.</p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>vector</tag>
      </tags>
  </entry>
  <entry>
    <title>14.Longest Common Prefix</title>
    <url>/posts/4084900668/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Write a function to find the longest common prefix string amongst an array of strings.<br>If there is no common prefix, return an empty string “”.</p>
<p>Example 1:<br>Input: [“flower”,”flow”,”flight”]<br>Output: “fl”</p>
<p>Example 2:<br>Input: [“dog”,”racecar”,”car”]<br>Output: “”</p>
<p>Explanation: There is no common prefix among the input strings.</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>题目意思是找到最长并且一样的前缀，如果没有一样的前缀，就返回空的字符串</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><h1 id="高票解法"><a href="#高票解法" class="headerlink" title="高票解法"></a>高票解法</h1><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h2><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><h1 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h1>]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>28.Implement strStr</title>
    <url>/posts/2690412730/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Implement strStr().</p>
<p>Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p>
<p>Example 1:<br>Input: haystack = “hello”, needle = “ll”<br>Output: 2</p>
<p>Example 2:<br>Input: haystack = “aaaaa”, needle = “bba”<br>Output: -1</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = haystack.length();</span><br><span class="line">        <span class="keyword">int</span> len2 = needle.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len1-len2+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (haystack.substr(i,len2) == needle)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 8 ms, faster than 80.56% of C++ online submissions for Implement strStr().<br>Memory Usage: 9.3 MB, less than 53.68% of C++ online submissions for Implement strStr().</p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>38.Count and Say</title>
    <url>/posts/2107205244/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>The count-and-say sequence is the sequence of integers with the first five terms as following:</p>
<ol>
<li>1</li>
<li>11</li>
<li>21</li>
<li>1211</li>
<li>111221</li>
</ol>
<p>1 is read off as “one 1” or 11.<br>11 is read off as “two 1s” or 21.<br>21 is read off as “one 2, then one 1” or 1211.</p>
<p>Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence.</p>
<p>Note: Each term of the sequence of integers will be represented as a string.</p>
<p>Example 1:</p>
<p>Input: 1<br>Output: “1”<br>Example 2:</p>
<p>Input: 4<br>Output: “1211”</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>看完这个题目真的一头雾水，完全没有理解题目要干什么，看了下discuss里面有一个不错的题目解读：</p>
<blockquote>
<p>初始值第一行是 1。<br>第二行读第一行，1 个 1，去掉个字，所以第二行就是 11。<br>第三行读第二行，2 个 1，去掉个字，所以第三行就是 21。<br>第四行读第三行，1 个 2，1 个 1，去掉所有个字，所以第四行就是 1211。<br>第五行读第四行，1 个 1，1 个 2，2 个 1，去掉所有个字，所以第五航就是 111221。<br>第六行读第五行，3 个 1，2 个 2，1 个 1，去掉所以个字，所以第六行就是 312211。<br>然后题目要求输入 1 - 30 的任意行数，输出该行是啥。</p>
</blockquote>
<p>题目还说输入是在1～30之内的一个整数，所以可以从1开始数，一直数到输入的数字。</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str = <span class="string">"1"</span>;</span><br><span class="line">        <span class="keyword">while</span>(--n)&#123;</span><br><span class="line">            <span class="built_in">string</span> tmp;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> iter = str.begin();iter != str.end();iter++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (*iter == *(iter + <span class="number">1</span>))&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    tmp += to_string(count);</span><br><span class="line">                    tmp += (*iter);</span><br><span class="line">                    count = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            str = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 4 ms, faster than 100.00% of C++ online submissions for Count and Say.<br>Memory Usage: 8.9 MB, less than 57.06% of C++ online submissions for Count and Say.</p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>9.Palindrome Number</title>
    <url>/posts/837075/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.</p>
<p>Example 1:<br>Input: 121<br>Output: true</p>
<p>Example 2:<br>Input: -121<br>Output: false<br>Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.</p>
<p>Example 3:<br>Input: 10<br>Output: false<br>Explanation: Reads 01 from right to left. Therefore it is not a palindrome.</p>
<p>Follow up:<br>Coud you solve it without converting the integer to a string?</p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>题目要求是判断一个数是不是palindrome。一个数如果是palindrome，那么它从左往右读和从右往左读都是一样的。并且负数不是palindrome。并且最好在不将整数转换为string的情况下完成。</p>
<p>其实可以用<a href="https://yutouwd.github.io/posts/1020379111">第七题</a>第思路，只要一个数反转过来和它相等，那么它就是palindrome。</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">10</span> &amp;&amp; x &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rev = <span class="number">0</span>, x_val = x;</span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (rev &gt; INT_MAX/<span class="number">10</span> || (rev == INT_MAX / <span class="number">10</span> &amp;&amp; pop &gt; <span class="number">7</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            rev = rev * <span class="number">10</span> + pop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rev == x_val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>✔ Accepted<br>  ✔ 11509/11509 cases passed (32 ms)<br>  ✔ Your runtime beats 99.62 % of cpp submissions<br>  ✔ Your memory usage beats 99.33 % of cpp submissions (8.2 MB)</p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>7.Reverse Interger</title>
    <url>/posts/1020379111/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given a 32-bit signed integer, reverse digits of an integer. </p>
<p>Example 1:<br>Input: 123<br>Output: 321 </p>
<p>Example 2:<br>Input: -123<br>Output: -321 </p>
<p>Example 3:<br>Input: 120<br>Output: 21 </p>
<p>Note:<br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. </p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>给一个32位的整数，然后将这个数反转过来。如果反转过来的数溢出了，就返回0。</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">0</span>, z = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)&#123;</span><br><span class="line">            y = z * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (y / <span class="number">10</span> != z)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            z = y;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个是之前不知道多久做的了，之前是可以Accepted的，但是现在会报runtime error: singled integer overflow: 964632435 * 10 cannot be represented in type ‘int’. 现在溢出都会有检查了吗。。。</p>
<h1 id="高票解法"><a href="#高票解法" class="headerlink" title="高票解法"></a>高票解法</h1><p>来看看官方的solution吧。</p>
<h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>它的思路其实很简单：</p>
<blockquote>
<p>就是重复的将x的最后一位pop出来，然后再push到rev中，最后rev就储存了反转后的结果了。但是只是这么做是很危险的，因为会产生溢出。但幸运的是有简单的办法在溢出前进行检查，假设x为正数。</p>
<ul>
<li>如果\(temp=rev*10+pop\)导致溢出，所以就有\(rev&gt;=\frac{INTMAX}{10}\)</li>
<li>如果\(rev&gt;\frac{INTMAX}{10}\)，那么\(temp=rev*10+pop\)一定会溢出</li>
<li>如果\(rev=\frac{INTMAX}{10}\)，那么\(temp=rev*10+pop\)会溢出当\(pop&gt;7\)</li>
</ul>
</blockquote>
<p>当x为负数的时候，逻辑是一样的，不过就是要将第三点改为\(pop&lt;-8\)，因为int型的范围是[-2147483648,2147483647]</p>
<h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (rev &gt; INT_MAX/<span class="number">10</span> || (rev == INT_MAX / <span class="number">10</span> &amp;&amp; pop &gt; <span class="number">7</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (rev &lt; INT_MIN/<span class="number">10</span> || (rev == INT_MIN / <span class="number">10</span> &amp;&amp; pop &lt; <span class="number">-8</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            rev = rev * <span class="number">10</span> + pop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码时间复杂度为O(logx)</p>
<h1 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h1><p>学习了检查int型溢出的方法。</p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>1.Two Sum</title>
    <url>/posts/2304652807/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target. </p>
<p>You may assume that each input would have exactly one solution, and you may not use the same element twice. </p>
<p>Example: </p>
<p>Given nums = [2, 7, 11, 15], target = 9, </p>
<p>Because nums[0] + nums[1] = 2 + 7 = 9,<br>return [0, 1]. </p>
<h1 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>题目的意思是给到一个整形的数组和一个目标，要在这个数组里面找到两个数相加等于这个目标的两个数，并返回这两个数的索引数组。并且可以假定每个输入必有且只有一个解，不能用一个数两次。</p>
<p>简单的想法就是用两个for循环，遍历数组里两个数相加的组合，如果相加等于目标，就返回这两个索引值。</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; index;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() - <span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target)&#123;</span><br><span class="line">                    index.push_back(i);</span><br><span class="line">                    index.push_back(j);</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结果如下：<br>✔ Accepted<br>  ✔ 29/29 cases passed (144 ms)<br>  ✔ Your runtime beats 32.13 % of cpp submissions<br>  ✔ Your memory usage beats 99.9 % of cpp submissions (9.2 MB)<br>速度有点点的慢</p>
<h1 id="高票解法"><a href="#高票解法" class="headerlink" title="高票解法"></a>高票解法</h1><p>看了下高票以及速度较快的解法，基本都是用了hash表。之前做题的时候也经常可以见到，但是一直也都没有太理解它的用法</p>
<h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; indices;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indices.find(target - nums[i]) != indices.end()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;indices[target - nums[i]], i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            indices[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h1><p>先好好了解一下哈希表和C++中的map和inorder_map的用法。</p>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>vector</tag>
        <tag>hashmap</tag>
      </tags>
  </entry>
  <entry>
    <title>成为一个「数据标记员」</title>
    <url>/posts/921238856/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>语音是自然的、有人性的。这也是为什么我们希望为机器建立可用的语音技术。但要创造一个语音系统，开发者需要大量的语音数据。</p>
<p>大部分由大公司持有的数据，并未开放给公众使用。我们认为这会扼杀创新，因而推出了Common Voice项目，让语音识别技术的大门对每个人开放而无障碍。</p>
<p>现在，您可以贡献出您的声音，帮助我们建立一个开源的语音数据库，任何人都可以使用它来为设备和网络制作创新的应用程序。 只要朗读一段文字，即可帮助机器了解人们如何说话。您也可以复查其他贡献者的工作以提高质量。就这么简单!<br><a id="more"></a><br>前段时间在公众号上看到了又有一个语音的数据集公开了，后来某一天有意无意的就去查了下这个数据集，点开了Common Voice的<a href="https://voice.mozilla.org/" target="_blank" rel="noopener">官网</a>，就看到了上面那一段话。一直都会被这种真正为了整个世界进步的精神所感染。</p>
<p>在之前公司工作的时候一个逃不掉的问题就是数据了，总是会因为没有开源的数据或者数据量太少而捉襟见肘，而大公司们就可以利用现有的资源去获得海量的数据。所以一开始看到Common Voice的官网就格外的激动，不过那个时候汉语（中国大陆）还没有上线，还在准备当中，于是就先去验证了几个汉语（台湾）的片段，也大概搞懂了它收集数据的方式。</p>
<p><img src="/upload_image/CommonVoiceVeri.png" alt></p>
<p>每个人都可以贡献自己的录音，朗读屏幕上的句子；也可以去验证别人读的句子，听别人读的和屏幕上的文本是否一致，如果3个人有2个人认为是对的就可以收录进数据集当中了，虽然感觉验证的次数可能稍微少了点，不过这也是为数不多不用专用的数据标记人员来制作数据集的办法了吧。</p>
<p>目前Common Voice已经上线了23种语言，汉语（中国大陆）也终于上线了，我也马上去录制了几段语音🎙，快来和我一起成为一个「数据标记员」吧～</p>
<p><del>最后再吐槽下Common Voice选的文本也太拗口了吧，就像下面这段话，都要读好几遍才能读得通顺。而且感觉选的文本都有点太过于书面化了，还有不少的文言文🤦‍♂️，不过瑕不掩瑜吧。</del></p>
<p><img src="/upload_image/CommonVoiceSpeak.png" alt></p>
]]></content>
      <categories>
        <category>精神家园</category>
      </categories>
      <tags>
        <tag>语音识别</tag>
        <tag>声纹识别</tag>
        <tag>开源数据</tag>
        <tag>Common Voice</tag>
      </tags>
  </entry>
  <entry>
    <title>kaldi在Windows下的使用</title>
    <url>/posts/3944650563/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>其实不是特别推荐在Windows下使用kaldi，因为在egs下所有的脚本都无法运行，我也是弄了很久才在Windows下配置好kaldi，都一度差点弃坑。就连官方也说<strong>There is no commitment to support Windows. The Windows port of Kaldi is targeted at experienced developers who want to program their own apps using the kaldi libraries and are able to do the troubleshooting on their own.</strong>就让我来把坑填平那么一点点吧🧐<br><a id="more"></a></p>
<h1 id="kaldi在Windows下的安装"><a href="#kaldi在Windows下的安装" class="headerlink" title="kaldi在Windows下的安装"></a>kaldi在Windows下的安装</h1><h2 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h2><ul>
<li>git</li>
<li>cmake</li>
<li>Visual Studio 2017</li>
</ul>
<p>vs2017要注意安装win8.1 SDK，如果已经安装了vs2017，也可以在上方的菜单栏中的工具-&gt;获取工具和功能中来查看是否有安装。git和cmake的安装没有什么特别的，就不做介绍了。</p>
<img src="/posts/3944650563/1.jpg">
<h2 id="编译Openfst"><a href="#编译Openfst" class="headerlink" title="编译Openfst"></a>编译Openfst</h2><p>首先从github上将openfst clone下来。然后这里用cmake的方式来先编译出vs的工程文件，具体操作方法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/kkm000/openfst.git</span><br><span class="line">cd openfst</span><br><span class="line">mkdir build64</span><br><span class="line">cd build64</span><br><span class="line">cmake -G "Visual Studio 15 2017 Win64" ../</span><br></pre></td></tr></table></figure>
<p>如果这一步成功会显示以下提示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-- The C compiler identification is MSVC 19.11.25547.0</span><br><span class="line">-- The CXX compiler identification is MSVC 19.11.25547.0</span><br><span class="line">-- Check for working C compiler: C:/Program Files (x86)/Microsoft Visual Studio/2017/Community/VC/Tools/MSVC/14.11.25503/bin/Hostx86/x64/cl.exe</span><br><span class="line">-- Check for working C compiler: C:/Program Files (x86)/Microsoft Visual Studio/2017/Community/VC/Tools/MSVC/14.11.25503/bin/Hostx86/x64/cl.exe -- works</span><br><span class="line">-- Detecting C compiler ABI info</span><br><span class="line">-- Detecting C compiler ABI info - done</span><br><span class="line">-- Check for working CXX compiler: C:/Program Files (x86)/Microsoft Visual Studio/2017/Community/VC/Tools/MSVC/14.11.25503/bin/Hostx86/x64/cl.exe</span><br><span class="line">-- Check for working CXX compiler: C:/Program Files (x86)/Microsoft Visual Studio/2017/Community/VC/Tools/MSVC/14.11.25503/bin/Hostx86/x64/cl.exe -- works</span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - done</span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - done</span><br><span class="line">-- The following ICU libraries were not found:</span><br><span class="line">--   data (required)</span><br><span class="line">--   i18n (required)</span><br><span class="line">--   io (required)</span><br><span class="line">--   test (required)</span><br><span class="line">--   tu (required)</span><br><span class="line">--   uc (required)</span><br><span class="line">-- Failed to find all ICU components (missing: ICU_INCLUDE_DIR ICU_LIBRARY _ICU_REQUIRED_LIBS_FOUND)</span><br><span class="line">-- Could NOT find ZLIB (missing: ZLIB_LIBRARY ZLIB_INCLUDE_DIR)</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: C:/Users/jtrmal/Documents/openfst/build64</span><br></pre></td></tr></table></figure>
<p>成功后会在build64目录下面生成一个openfst.sln文件，用vs2017打开这个文件，分别用Debug|x64和Release|x64来生成一遍，如下图，如果失败为0则代表编译通过。</p>
<img src="/posts/3944650563/2.jpg">
<h2 id="配置OpenBLAS"><a href="#配置OpenBLAS" class="headerlink" title="配置OpenBLAS"></a>配置OpenBLAS</h2><p>首先也是从github上先将kaldi clone下来</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/kaldi-asr/kaldi.git kaldi</span><br></pre></td></tr></table></figure>
<p>然后我们就需要去配置线性代数库，这里有两个选择，一个是Intel MKL，一个是OpenBLAS。这里我选用OpenBLAS。用下面的命令来下载OpenBLAS的二进制包（在kaldi/tools目录下）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -L -O http://sourceforge.net/projects/openblas/files/v0.2.14/OpenBLAS-v0.2.14-Win64-int32.zip</span><br><span class="line">unzip OpenBLAS-v0.2.14-Win64-int32.zip</span><br></pre></td></tr></table></figure>
<p><strong>注意这里要下载Win64-int32版本，而不是Win64-int64版本</strong></p>
<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>进入kaldi/windows路径想，将varialbe.props.dev复制一份重命名为variables.props，打开后将刚刚配置好的库修改为自己的路径：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Change the following paths so they are correct on your machine --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Do not modify anything before this line --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MKLDIR</span>&gt;</span>C:\Program Files\(x86)\IntelSWTools\compilers_and_libraries\windows\mkl\<span class="tag">&lt;/<span class="name">MKLDIR</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">OPENBLASDIR</span>&gt;</span>C:\Users\Yenda\Downloads\kaldi-svn\tools\OpenBLAS-v0.2.14-Win64-int32<span class="tag">&lt;/<span class="name">OPENBLASDIR</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">OPENFST</span>&gt;</span>C:\Users\jtrmal\Documents\openfst<span class="tag">&lt;/<span class="name">OPENFST</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">OPENFSTLIB</span>&gt;</span>C:\Users\jtrmal\Documents\openfst\build64<span class="tag">&lt;/<span class="name">OPENFSTLIB</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Do not modify anything after this line --&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>我们需要将OpenBLAS和Openfst修改为自己的路径，因为没有用到MKL就不用修改了。下面就是我修改后的路径：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Change the following paths so they are correct on your machine --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Do not modify anything before this line --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MKLDIR</span>&gt;</span>C:\Program Files(x86)\IntelSWTools\compilers_and_libraries\windows\mkl\<span class="tag">&lt;/<span class="name">MKLDIR</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">OPENBLASDIR</span>&gt;</span>D:\git_home\kaldi\tools\OpenBLAS-v0.2.14-Win64-int32<span class="tag">&lt;/<span class="name">OPENBLASDIR</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">OPENFST</span>&gt;</span>D:\git_home\openfst<span class="tag">&lt;/<span class="name">OPENFST</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">OPENFSTLIB</span>&gt;</span>D:\git_home\openfst\build64<span class="tag">&lt;/<span class="name">OPENFSTLIB</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Do not modify anything after this line --&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="产生工程文件"><a href="#产生工程文件" class="headerlink" title="产生工程文件"></a>产生工程文件</h2><p>同样还是在kaldi/windows路径下，因为我们是使用OpenBLAS所以就把kaldiwin_openblas.props复制一份重命名为kaldiwin.prosp。然后在windows路径下用git bash运行以下命令：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./generate_solution.pl --vsver vs2017 --enable-openblas</span><br><span class="line">./get_version.pl</span><br></pre></td></tr></table></figure></p>
<h2 id="kaldi编译测试"><a href="#kaldi编译测试" class="headerlink" title="kaldi编译测试"></a>kaldi编译测试</h2><p>然后我们打开在kaldi/kaldiwin_vs2017_OPENBLAS这个新生成的文件夹，打卡里面的kaldiwin_vs2017.sln工程文件，这里面就包括了所有kaldi/src中*bin中的.cc文件。这时候需要来测试一下kaldi能否运行，首先要把Debug|Win32改为Debug|x64，然后右键选择online2-wav-nnet2-latgen-faster生成，如下图，如果生成成功则代表之前的工作都做对啦，kaldi已经配置好了✌️~exe文件会生成在kaldiwin_vs2017_OPENBLAS/x64/Debug中，不过当用命令行来运行刚刚生成的exe文件时，还是有可能会报错，如缺少dll等，解决方法见常见问题。</p>
<img src="/posts/3944650563/11.jpg">
<h1 id="kaldi在Windows下的调试"><a href="#kaldi在Windows下的调试" class="headerlink" title="kaldi在Windows下的调试"></a>kaldi在Windows下的调试</h1><h2 id="新建自己的kaldi项目"><a href="#新建自己的kaldi项目" class="headerlink" title="新建自己的kaldi项目"></a>新建自己的kaldi项目</h2><p>在配置好kaldi之后，就可以开始调试和编写自己的使用kaldi的程序了。不过原来的kaldi项目中有630个项目或者称为解决方案，每次打开都要加载很久。所以我们可以新建一个空项目：</p>
<img src="/posts/3944650563/4.jpg">
<h3 id="添加引用"><a href="#添加引用" class="headerlink" title="添加引用"></a>添加引用</h3><p>然后点击左上角文件-&gt;添加-&gt;现有项目，切换到kaldi/kaldiwin_vs2017_OPENBLAS/kaldiwin路径下。</p>
<img src="/posts/3944650563/5.jpg">
<p>最好把所有以kaldi开头的项目都添加进去（点进去具体的文件夹，添加.vcxproj文件），包含test的不用。不过如果你清楚你用的项目要用到哪些具体的引用，那么只添加特定的项目即可。那么要怎么看需要用到那些引用呢，这时就要回到之前那个包含630个项目的vs中去。</p>
<img src="/posts/3944650563/6.jpg">
<p>比如说我想要提取mfcc特征，就可以去看看compute-mfcc-feats这个项目中以用了那些项目，然后在自己的项目提取mfcc特征项目中，也要以用相同的项目，那么就把对应的项目添加到自己的项目中，如下图：</p>
<img src="/posts/3944650563/7.jpg">
<h3 id="添加工程属性表"><a href="#添加工程属性表" class="headerlink" title="添加工程属性表"></a>添加工程属性表</h3><p>配置好引用还需要我们去添加刚才配置好的vs工程属性表，点开左上菜单栏中的视图-&gt;其他窗口-&gt;属性管理器。</p>
<img src="/posts/3944650563/8.jpg">
<p>然后在自己的项目的Debug|64中添加variables.props kaldiwin.props openfst_debug.props（如果要release则添加对应的release版本）</p>
<h3 id="修改附加包含目录"><a href="#修改附加包含目录" class="headerlink" title="修改附加包含目录"></a>修改附加包含目录</h3><p>还差一步就大功告成，首先要在自己的项目中添加一个cpp文件，然后右键属性-&gt;C/C++-&gt;所有选项-&gt;附加包含目录，需要把kaldi/src目录添加进去</p>
<img src="/posts/3944650563/10.jpg">
<p>配置好之后，就可以写自己的调用kaldi的程序了，之后也可以按照这样的方式来。总结一下：</p>
<ul>
<li>在当前项目中文件-&gt;添加-&gt;新建项目</li>
<li>添加需要用到的引用</li>
<li>添加已经配置好的工程属性表</li>
<li>最后把kaldi/src添加到附加包含目录就可以了</li>
<li><strong><em>另外要记住调试模式要切换成Debug|x64</em></strong></li>
</ul>
<h2 id="写自己的kaldi程序"><a href="#写自己的kaldi程序" class="headerlink" title="写自己的kaldi程序"></a>写自己的kaldi程序</h2><p>如果想写自己的调用kaldi的程序要怎么开始呢，最好的办法就是去看run.sh中用到了哪些命令，然后在看命令中C++代码是怎么做的。以提取mfcc特征为例，在声纹识别中，一般都是下面几条命令用来提取mfcc特征：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> run.sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Now make MFCC features.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mfccdir should be some place with a largish disk <span class="built_in">where</span> you</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> want to store MFCC features.</span></span><br><span class="line">mfccdir=mfcc</span><br><span class="line">for x in train test; do</span><br><span class="line">  steps/make_mfcc.sh --cmd "$train_cmd" --nj 10 data/$x exp/make_mfcc/$x $mfccdir</span><br><span class="line">  sid/compute_vad_decision.sh --nj 10 --cmd "$train_cmd" data/$x exp/make_mfcc/$x $mfccdir</span><br><span class="line">  utils/fix_data_dir.sh data/$x</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>具体的提取mfcc的特征程序就在steps/make_mfcc.sh中了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> make_mfcc.sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash">cmd JOB=1:<span class="variable">$nj</span> <span class="variable">$logdir</span>/make_mfcc_<span class="variable">$&#123;name&#125;</span>.JOB.log \</span></span><br><span class="line">  extract-segments scp,p:$scp $logdir/segments.JOB ark:- \| \</span><br><span class="line">  compute-mfcc-feats $vtln_opts --verbose=2 --config=$mfcc_config ark:- ark:- \| \</span><br><span class="line">  copy-feats --compress=$compress $write_num_frames_opt ark:- \</span><br><span class="line">  ark,scp:$mfccdir/raw_mfcc_$name.JOB.ark,$mfccdir/raw_mfcc_$name.JOB.scp \</span><br><span class="line">  || exit 1;</span><br></pre></td></tr></table></figure>
<p>里面具体提取mfcc特征的命令就应该是steps/make_mfcc.sh了，看下make_mfcc.sh，在经过一系列处理后，使用compute-mfcc-feat这个命令来提取mfcc特征的。我们就可以去看在featbin下的compute-mfcc-feat.cc中是如何提取mfcc特征的，下面就贴上我的提取mfcc并写入一个txt文件的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"feat/feature-mfcc.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"feat/wave-reader.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"base/kaldi-math.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"matrix/kaldi-matrix-inl.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"matrix/kaldi-vector.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> kaldi;   <span class="comment">//要记住使用namespace kaldi</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> * Usage =</span><br><span class="line">            <span class="string">"my_kaldi.exe [wav_filename] [mfcc_filename] \n"</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function">ParseOptions <span class="title">po</span><span class="params">(Usage)</span></span>;</span><br><span class="line">        po.Read(argc, argv);</span><br><span class="line">        <span class="keyword">if</span> (po.NumArgs() != <span class="number">2</span>) &#123;</span><br><span class="line">            po.PrintUsage();</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> wav_filename = po.GetArg(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> mfcc_filename = po.GetArg(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*读取wav文件*/</span></span><br><span class="line">        <span class="built_in">std</span>::ifstream wav_file;</span><br><span class="line">        wav_file.open(wav_filename, <span class="built_in">std</span>::ios_base::binary);</span><br><span class="line">        WaveData wave;</span><br><span class="line">        wave.Read(wav_file);</span><br><span class="line">        SubVector&lt;BaseFloat&gt; waveform(wave.Data(), <span class="number">0</span>);<span class="comment">//将wav文件数据放到waveform中</span></span><br><span class="line">              </span><br><span class="line">        <span class="comment">/*mfcc特征配置*/</span></span><br><span class="line">        MfccOptions mfcc_opts;</span><br><span class="line">        mfcc_opts.frame_opts.samp_freq = <span class="number">16000</span>;</span><br><span class="line">        mfcc_opts.frame_opts.frame_length_ms = <span class="number">25</span>;</span><br><span class="line">        mfcc_opts.frame_opts.frame_shift_ms = <span class="number">10</span>;</span><br><span class="line">        mfcc_opts.frame_opts.preemph_coeff = <span class="number">0.95</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*提取mfcc特征*/</span></span><br><span class="line">        Matrix&lt;BaseFloat&gt; mfcc_feature;</span><br><span class="line">        <span class="function">Mfcc <span class="title">feat</span><span class="params">(mfcc_opts)</span></span>;</span><br><span class="line">        feat.ComputeFeatures(waveform, wave.SampFreq(), <span class="number">1.0</span>, &amp;mfcc_feature);</span><br><span class="line">              </span><br><span class="line">        <span class="comment">/*写入到文件中*/</span></span><br><span class="line">        WriteKaldiObject(mfcc_feature,mfcc,<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//kaldi中都可以使用WriteKaldiObject来写使用到的kaldi对象</span></span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="built_in">std</span>::exception &amp;e) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; e.what();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="kaldi模型的读取"><a href="#kaldi模型的读取" class="headerlink" title="kaldi模型的读取"></a>kaldi模型的读取</h2><p>在windows上跑kaldi，不可避免地会用到kaldi中的I/O接口，比如读取在Linux下已经训练好的模型等。kaldi中的模型往往都是一个类，比如说声纹识别中用到的UBM类FullGmm，提取ivector的IvectorExtractor等等，对于这些类的提取都可以用ReadKaldiObject来完成</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> kaldi;</span><br><span class="line">FullGmm fgmm;                           <span class="comment">//首先要声明想要读取的模型的类</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> ubmFile = <span class="string">"final.ubm"</span>;    <span class="comment">//然后确定文件名</span></span><br><span class="line">ReadKaldiObject(ubmFile, &amp;fgmm);</span><br></pre></td></tr></table></figure>
<p>对于其他的模型，也可以通过类似的方法来读取到内存中。如果想把模型等写出来也可以通过WriteKaldiObject来完成。</p>
<h1 id="kaldi在Windows下的移植"><a href="#kaldi在Windows下的移植" class="headerlink" title="kaldi在Windows下的移植"></a>kaldi在Windows下的移植</h1><p>此处的移植指的是能够使kaldi在一台没有开发环境下的电脑中正常运行。刚开始要做的时候感觉可能会有各种的坑，不过实际中做要比想象中简单得多，如果上面配置基本没什么问题，移植的话也就没什么问题了。</p>
<h2 id="生成exe"><a href="#生成exe" class="headerlink" title="生成exe"></a>生成exe</h2><p>生成exe其实很简单，在每次Debug的时候都会自动生成一个可执行文件，不过要想在一个没有开发环境的电脑上使用，要用Release来重新生成一下。我们可以用main(int argc, char * argv[])来读取命令行的参数，然后可以用ParseOptions po(Usage);来控制输入的参数，具体参考上面提取mfcc的代码，这里就不做过多的介绍了。在移植过程中还遇到的一个问题就是缺少一些dll，主要是mingw的一些dll，解决方法见下面遇到的问题。</p>
<h2 id="生成dll"><a href="#生成dll" class="headerlink" title="生成dll"></a>生成dll</h2><p>如果想生成dll打包给其他程序用，就需要在头文件中想要导出的函数的前面加上declspec(dllexport)，并且右键右侧的项目属性栏，把常规中的项目默认值-&gt;配置类型改为动态库（.dll）</p>
<h1 id="遇到的问题记录"><a href="#遇到的问题记录" class="headerlink" title="遇到的问题记录"></a>遇到的问题记录</h1><h2 id="cmake生成Openfst工程文件失败"><a href="#cmake生成Openfst工程文件失败" class="headerlink" title="cmake生成Openfst工程文件失败"></a>cmake生成Openfst工程文件失败</h2><img src="/posts/3944650563/9.jpg">
<p>根据错误提示，应该是缺少了fst_test.h weight-tester.h algo_test.h，在openfst/src目录下搜索这几个文件，发现都在openfst\src\include\fst\test中，于是把几个文件都复制过来，然后再执行那条cmake的命令，就可以成功了~。</p>
<h2 id="缺少libopenblas-dll"><a href="#缺少libopenblas-dll" class="headerlink" title="缺少libopenblas.dll"></a>缺少libopenblas.dll</h2><p>当在命令行或git bash中运行生成好的exe时，会报错缺少libopenblas.dll：</p>
<img src="/posts/3944650563/3.png">
<p>我们需要将之前下载的OpenBLAS中bin目录下的libopenblas.dll拷到和exe文件同一个文件夹中就可以执行了。</p>
<h2 id="mingw-dll下载"><a href="#mingw-dll下载" class="headerlink" title="mingw dll下载"></a>mingw dll下载</h2><p>包括libgcc_s_seh-1.dll libgfortran-3.dll libquadmath-0.dll，下载后同样需要放到和exe同一目录下。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -L -O http://sourceforge.net/projects/openblas/files/v0.2.14/mingw64_dll.zip</span><br><span class="line">unzip mingw64_dll.zip</span><br></pre></td></tr></table></figure></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>官方Windows下安装指南：<br><a href="https://github.com/kaldi-asr/kaldi/blob/master/windows/INSTALL.md" target="_blank" rel="noopener">https://github.com/kaldi-asr/kaldi/blob/master/windows/INSTALL.md</a><br>一个中文的安装说明：<br><a href="https://www.jianshu.com/p/5494d6607789" target="_blank" rel="noopener">https://www.jianshu.com/p/5494d6607789</a><br>Windows下安装常见的问题：<br><a href="https://blog.csdn.net/qq_25867649/article/details/78356474?locationNum=8&amp;fps=1" target="_blank" rel="noopener">https://blog.csdn.net/qq_25867649/article/details/78356474?locationNum=8&amp;fps=1</a><br>kaldi中IO接口介绍：<br><a href="http://kaldi-asr.org/doc/io.html" target="_blank" rel="noopener">http://kaldi-asr.org/doc/io.html</a></p>
]]></content>
      <categories>
        <category>声纹识别</category>
        <category>kaldi</category>
      </categories>
      <tags>
        <tag>声纹识别</tag>
        <tag>kaldi</tag>
        <tag>Visual Studio</tag>
      </tags>
  </entry>
  <entry>
    <title>博客折腾记录</title>
    <url>/posts/87e6cb09/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>之前一直没有记录修改&amp;优化博客的过程，其实这是一个不太好的习惯，现在都忘了自己修改过哪些地方了(虽然vscode可以标出来)，哪些修改对应了网站哪些变化。所以还是要记录一下修改的记录，为方便日后对博客持续优化。</p>
<h2 id="things-to-do"><a href="#things-to-do" class="headerlink" title="things to do"></a>things to do</h2><ul>
<li style="list-style: none"><input type="checkbox" checked> 修改站点下博客文章存放目录</li>
<li style="list-style: none"><input type="checkbox" checked> 侧边栏toc自动展开</li>
<li style="list-style: none"><input type="checkbox" checked> 评论系统更换为valine</li>
<li style="list-style: none"><input type="checkbox"> 站点自动备份系统</li>
<li style="list-style: none"><input type="checkbox"> 文章分类、归档页面优化</li>
<li style="list-style: none"><input type="checkbox"> 代码块优化</li>
<li style="list-style: none"><input type="checkbox" checked> next版本升级</li>
<li style="list-style: none"><input type="checkbox"> SEO优化</li>
<li style="list-style: none"><input type="checkbox" checked> leetcode文章归档</li>
<li style="list-style: none"><input type="checkbox" checked> 不再使用notshow来隐藏文章</li>
<li style="list-style: none"><input type="checkbox" checked> 增加搜索功能<a id="more"></a>
</li>
</ul>
<h2 id="修改站点下博客文章存放目录"><a href="#修改站点下博客文章存放目录" class="headerlink" title="修改站点下博客文章存放目录"></a>修改站点下博客文章存放目录</h2><p>这个其实是在找解决如何将侧边栏toc自动展开时，找到一篇<a href="https://blog.dongleizhang.com/posts/32005d86/" target="_blank" rel="noopener">博客</a>无意中发现的。原来那种年/月/日…的方式真的太挫了，于是就按照他的这种方式，生成一个永久链接。<br>首先安装hexo-abbrlink插件，使用命令 npm install hexo-abbrlink –save 即可。然后需要在站点配置文件，即hexo目录下的_config.yml文件中修改 permalink: :year/:month/:day/:title/ 为一下内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">permalink: posts/:abbrlink/</span><br><span class="line">abbrlink:</span><br><span class="line">  alg: crc32  <span class="comment">#support crc16(default) and crc32</span></span><br><span class="line">  rep: hex    <span class="comment">#support dec(default) and hex</span></span><br></pre></td></tr></table></figure>
<p>然后在hexo clean和hexo g &amp;&amp; hexo d即可。不过令人伤心的是，在重新生成文章链接后原来的阅读量也随之清零了😭，我这可怜的阅读量不知道什么时候才能四位数啊。</p>
<h2 id="侧边栏toc自动展开"><a href="#侧边栏toc自动展开" class="headerlink" title="侧边栏toc自动展开"></a>侧边栏toc自动展开</h2><p>目前在github上找到了几个issue:<a href="https://github.com/theme-next/hexo-theme-next/issues/307" target="_blank" rel="noopener">#307</a> <a href="https://github.com/iissnan/hexo-theme-next/issues/531" target="_blank" rel="noopener">#531</a> <a href="https://github.com/iissnan/hexo-theme-next/issues/710" target="_blank" rel="noopener">#710</a><br>具体的解决方法就是在themes/next/source/_custom/custom.styl中加入以下代码，可以自动展开二级标题。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.post-toc .nav .nav-level-1&gt;.nav-child &#123; </span><br><span class="line">   display: block; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="评论系统更换为valine"><a href="#评论系统更换为valine" class="headerlink" title="评论系统更换为valine"></a>评论系统更换为valine</h2><p>真的受不了disqus，首先被河蟹了，然后即使能加载也非常的慢，界面也十分的丑。今天看到一些博客用了valine发现比disqus好看多了，抽时间赶紧把这个给改了。<br>一开始弄好了，但是发现刷新后评论就会消失。后来在github上问了下<a href="https://github.com/xCss/Valine/issues/159" target="_blank" rel="noopener">#159</a>，原来valine和next自带的统计阅读量会有冲突。然后还发现一个很严重的问题，一开始在选主题的时候没有仔细调研，就下了旧的next版本5.1.4。现在最新的next版本已经到6点多，并且在另外一个仓库中。所以又想把next换成最新的版本。</p>
<h2 id="站点自动备份系统"><a href="#站点自动备份系统" class="headerlink" title="站点自动备份系统"></a>站点自动备份系统</h2><p><a href="https://notes.doublemine.me/2015-07-06-%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BDHexo%E5%8D%9A%E5%AE%A2%E6%BA%90%E6%96%87%E4%BB%B6.html" target="_blank" rel="noopener">https://notes.doublemine.me/2015-07-06-%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BDHexo%E5%8D%9A%E5%AE%A2%E6%BA%90%E6%96%87%E4%BB%B6.html</a></p>
<h2 id="文章分类、归档页面优化"><a href="#文章分类、归档页面优化" class="headerlink" title="文章分类、归档页面优化"></a>文章分类、归档页面优化</h2><p>查了一下才发现，原来hexo已经支持二级分类了</p>
<h2 id="代码块优化"><a href="#代码块优化" class="headerlink" title="代码块优化"></a>代码块优化</h2><p>代码块mac风格<br><a href="https://blog.ihoey.com/posts/Hexo/2018-05-27-hexo-code-block.html" target="_blank" rel="noopener">https://blog.ihoey.com/posts/Hexo/2018-05-27-hexo-code-block.html</a><br>代码块复制(在next7.0中已经集成了代码块复制功能)<br><a href="https://qiming.info/Hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%8A%A0%E5%85%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E5%A4%8D%E5%88%B6%E5%8A%9F%E8%83%BD/" target="_blank" rel="noopener">https://qiming.info/Hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%8A%A0%E5%85%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E5%A4%8D%E5%88%B6%E5%8A%9F%E8%83%BD/</a></p>
<h2 id="next版本升级"><a href="#next版本升级" class="headerlink" title="next版本升级"></a>next版本升级</h2><p>升级到7.0，先将就的themes/next文件夹重命名为next-old，然后在把最新的next下载到themes/next中，在把之前的一些配置修改一下。不知道为什么新的字数统计加载不出来，还是想用回原来的。现在next-old/_config.yml中找到原来的wordcount设置字段复制到新的next的_cogfig.yml中。先找到了整个网站页低的字数统计是在theme/next/layout/footer.swig中设置的。将旧的wordcount的设置复制过去，就可以了。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.post_wordcount.totalcount %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-divider"</span>&gt;</span>|<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-icon"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-area-chart"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  &#123;% if theme.post_wordcount.item_text %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-text"</span>&gt;</span>&#123;&#123; __('文字总数') &#125;&#125;&amp;#58;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">title</span>=<span class="string">"&#123;&#123; __('post.totalcount') &#125;&#125;"</span>&gt;</span>&#123;#</span><br><span class="line">  #&#125;&#123;&#123; totalcount(site, '0,0.0a') &#125;&#125;&#123;#</span><br><span class="line">#&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后还需要修改每篇文章上的显示设置，在旧的next主题github地址<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a> 中搜索 post_wordcount 可以找到在next/layout/_marco/post.swig中有用到，那么这里就应该是设置每篇文章的字数统计的地方。再把旧的和新的对比一下把旧的包括post_wordcount的代码复制过去，就大功告成。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.post_wordcount.wordcount or theme.post_wordcount.min2read %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post-wordcount"</span>&gt;</span></span><br><span class="line">    &#123;% if theme.post_wordcount.wordcount %&#125;</span><br><span class="line">      &#123;% if not theme.post_wordcount.separated_meta %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-divider"</span>&gt;</span>|<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      &#123;% endif %&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-icon"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-file-word-o"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      &#123;% if theme.post_wordcount.item_text %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-text"</span>&gt;</span>&#123;&#123; __('字数统计') &#125;&#125;&amp;#58;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      &#123;% endif %&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">title</span>=<span class="string">"&#123;&#123; __('post.wordcount') &#125;&#125;"</span>&gt;</span></span><br><span class="line">        &#123;&#123; wordcount(post.content) &#125;&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">    &#123;% if theme.post_wordcount.wordcount and theme.post_wordcount.min2read %&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-divider"</span>&gt;</span>|<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">    &#123;% if theme.post_wordcount.min2read %&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-icon"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-clock-o"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      &#123;% if theme.post_wordcount.item_text %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-text"</span>&gt;</span>&#123;&#123; __('阅读时间') &#125;&#125; &amp;asymp;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      &#123;% endif %&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">title</span>=<span class="string">"&#123;&#123; __('post.min2read') &#125;&#125;"</span>&gt;</span></span><br><span class="line">        &#123;&#123; min2read(post.content) &#125;&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SEO优化"><a href="#SEO优化" class="headerlink" title="SEO优化"></a>SEO优化</h2><p>终于空下来有时间弄弄博客啦，首先就是感觉把SEO弄了，一直都拖了好久。SEO主要参考了这篇博客<a href="https://blog.csdn.net/qq_34149805/article/details/84894713" target="_blank" rel="noopener">https://blog.csdn.net/qq_34149805/article/details/84894713</a>和<a href="https://www.jianshu.com/p/c20bb9df1867" target="_blank" rel="noopener">https://www.jianshu.com/p/c20bb9df1867</a>以及<a href="https://felixxiong.github.io/2018/10/06/%E5%8D%9A%E5%AE%A2SEO%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96/" target="_blank" rel="noopener">https://felixxiong.github.io/2018/10/06/%E5%8D%9A%E5%AE%A2SEO%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96/</a></p>
<p>不过现在卡在百度的认证上了，下载认证文件放到next主题目录的路径下，会显示验证失败：“您的站点有链接未通过https校验“黑人问号？？？</p>
<h2 id="leetcode文章归档"><a href="#leetcode文章归档" class="headerlink" title="leetcode文章归档"></a>leetcode文章归档</h2><p>想法是写leetcode的文章不会自动显示在主页上，然后新建一个page，里面专门收录写的关于leetcoede的文章。可以在scaffolds目录中新建一个leet.md，以后直接用hexo new leet [leet题目]这样方式来新建一个文章。将文章不显示在主页的方法参考这篇文章<a href="https://www.jianshu.com/p/79fe9fb9dfa0" target="_blank" rel="noopener">https://www.jianshu.com/p/79fe9fb9dfa0</a>，修改好之后，就在leet.md中加上notshow: true，以后新建就可以自动设置为不显示了。</p>
<p>然后还想弄一个类似于github上个人主页那种日历表，如果有一天有做题的话，就会设置成绿色。找了下，发现可以通过baidu的echart或者google chart来实现。baidu的好处就是有中文的文档，google的例子似乎更好看一些，但是不知道会不会被emmmm，就还是先试试百度的吧。只要<strong>npm install hexo-tag-echarts3 –save</strong>就可以来，下面是一个echart测试：</p>
<div id="echarts9912" style="width: 85%;height: 400px;margin: 0 auto"></div>
<script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script>
<script type="text/javascript">
        // 基于准备好的dom，初始化echarts实例
        var myChart = echarts.init(document.getElementById('echarts9912'));
        // 指定图表的配置项和数据
        var option = {
    tooltip : {
        trigger: 'axis',
        axisPointer : {            // 坐标轴指示器，坐标轴触发有效
            type : 'shadow'        // 默认为直线，可选为：'line' | 'shadow'
        }
    },
    legend: {
        data:['利润', '支出', '收入']
    },
    grid: {
        left: '3%',
        right: '4%',
        bottom: '3%',
        containLabel: true
    },
    xAxis : [
        {
            type : 'value'
        }
    ],
    yAxis : [
        {
            type : 'category',
            axisTick : {show: false},
            data : ['周一','周二','周三','周四','周五','周六','周日']
        }
    ],
    series : [
        {
            name:'利润',
            type:'bar',
            itemStyle : {
                normal: {
                    label: {show: true, position: 'inside'}
                }
            },
            data:[200, 170, 240, 244, 200, 220, 210]
        },
        {
            name:'收入',
            type:'bar',
            stack: '总量',
            itemStyle: {
                normal: {
                    label : {show: true}
                }
            },
            data:[320, 302, 341, 374, 390, 450, 420]
        },
        {
            name:'支出',
            type:'bar',
            stack: '总量',
            itemStyle: {normal: {
                label : {show: true, position: 'left'}
            }},
            data:[-120, -132, -101, -134, -190, -230, -210]
        }
    ]
};
        // 使用刚指定的配置项和数据显示图表。
        myChart.setOption(option);
</script>
<p>可以点击上方的利润、收入、支出来设置显示和不显示，还是很炫酷滴🕶️，接下来试下日历表：</p>
<div id="echarts8618" style="width: 85%;height: 400px;margin: 0 auto"></div>
<script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script>
<script type="text/javascript">
        // 基于准备好的dom，初始化echarts实例
        var myChart = echarts.init(document.getElementById('echarts8618'));
        // 指定图表的配置项和数据
        var option = 
option = {
    title: {
        top: 30,
        left: 'center',
        text: '2016年某人每天的步数'
    },
    tooltip : {},
    visualMap: {
        min: 0,
        max: 10000,
        type: 'piecewise',
        orient: 'horizontal',
        left: 'center',
        top: 65,
        textStyle: {
            color: '#000'
        }
    },
    calendar: {
        top: 120,
        left: 30,
        right: 30,
        cellSize: ['auto', 13],
        range: '2019',
        itemStyle: {
            normal: {borderWidth: 0.5}
        },
        yearLabel: {show: false}
    },
    series: {
        type: 'heatmap',
        coordinateSystem: 'calendar',
        data: [Date(2019,1,1),10000]
    }
};

        // 使用刚指定的配置项和数据显示图表。
        myChart.setOption(option);
</script>
<p>好吧，好像不能显示…不知道是因为echart没写好还是不支持…那就先搁置下来，以后有时间就试试google的吧，但是hexo中google chart的插件最后一次更新已经是4年前了。</p>
<h2 id="不再使用notshow来隐藏文章"><a href="#不再使用notshow来隐藏文章" class="headerlink" title="不再使用notshow来隐藏文章"></a>不再使用notshow来隐藏文章</h2><p>2020.2.13更新<br><a href="https://www.jianshu.com/p/79fe9fb9dfa0" target="_blank" rel="noopener">https://www.jianshu.com/p/79fe9fb9dfa0</a><br>用了很久的notshow来隐藏不想显示在主页的文章，但是用久了会有一个问题，就是虽然文章不在主页显示了，但是还是会算在主页的文章数当中，如果写了10篇notshow的文章，那么主页就是空白了。之前都是通过修改主页的文章显示数量来避免这个问题，现在终于下定决心去解决一下了。百度到了一个插件：<a href="https://github.com/Jamling/hexo-generator-index2" target="_blank" rel="noopener">https://github.com/Jamling/hexo-generator-index2</a>，这个插件可以根据标签、种类或路径来选择主页包括/不包括的文章，简直完美契合我的需求。把notshow给删掉了，然后安装好插件，只需要修改在hexo目录下的_config.yml，增加下面几行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># index2 generator是否包含官方的hexo-generator-index，默认true（包含）</span><br><span class="line">index2_include_index: true # defult is true</span><br><span class="line"></span><br><span class="line"># 配置index2 generator，可以是数组或对象</span><br><span class="line">index2_generator:</span><br><span class="line">  per_page: 10</span><br><span class="line">  order_by: -date</span><br><span class="line">  # include:</span><br><span class="line">  #   - category Web # 只包含Web分类下的文章</span><br><span class="line">  exclude:</span><br><span class="line">    - category leetcode # 不包含标签为Hexo的文章</span><br></pre></td></tr></table></figure>
<p>这个插件也有了很久了，不知道为什么之前没有找到。。。</p>
<h2 id="增加搜索功能"><a href="#增加搜索功能" class="headerlink" title="增加搜索功能"></a>增加搜索功能</h2><p>用的是hexo-generator-searchdb，先安装：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb</span><br></pre></td></tr></table></figure></p>
<p>然后修改next主题的配置文件中的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Local search</span><br><span class="line"># Dependencies: https://github.com/theme-next/hexo-generator-searchdb</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # if auto, trigger search by changing input</span><br><span class="line">  # if manual, trigger search by pressing enter key or search button</span><br><span class="line">  trigger: auto</span><br><span class="line">  # show top n results per article, show all results by setting to -1</span><br><span class="line">  top_n_per_article: 1</span><br><span class="line">  # unescape html strings to the readable one</span><br><span class="line">  unescape: false</span><br></pre></td></tr></table></figure></p>
<p>修改站点配置文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  content: true</span><br></pre></td></tr></table></figure></p>
<h2 id="教程收藏"><a href="#教程收藏" class="headerlink" title="教程收藏"></a>教程收藏</h2><p><a href="http://yearito.cn/tags/Hexo/" target="_blank" rel="noopener">http://yearito.cn/tags/Hexo/</a></p>
]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>个人博客</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习在声纹识别中的应用</title>
    <url>/posts/600d0d5d/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>随着深度学习的迅猛发展，神经网络在越来越多的方向得到了广泛的应用，声纹识别也不例外。有越来越多的使用神经网络的方法来进行声纹识别的文章，并且都取得了不错的效果。最近也看了挺多文章的，总的来说，大致可以分为两个方向：feature learning,大概就是训练一个神经网络当作特征提取器，然后使用提取出来代表说话人的特征再做分类；End to end就是指直接输入两段语音，然后通过神经网络来判断这两段语音是否来自同一个人。<br><a id="more"></a></p>
<h1 id="Feature-Learning"><a href="#Feature-Learning" class="headerlink" title="Feature Learning"></a>Feature Learning</h1><h2 id="d-vector"><a href="#d-vector" class="headerlink" title="d-vector"></a>d-vector</h2><p>最早在2014年Google将神经网络用于声纹识别：<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.674.3686&amp;rep=rep1&amp;type=pdf" target="_blank" rel="noopener">Deep Neural Networks for Small Footprint Text-Dependent</a>。它使用了一个四层的全连接层的网络来完成文本相关的声纹识别任务。它的结构如下：</p>
<p><img src="/upload_image/3.png" alt></p>
<p>它使用40维的filterbank特征（和MFCC相比少了离散余弦变换），然后使用当前帧的以及它的前后两帧作为输入，即一个120维的一维向量作为输入。经过四层的全连接层，每层有256个节点，使用maxout作为激活函数，最后两层加入dropout。训练时使用帧级别（frame level）的特征，使用softmax分类。</p>
<p>在网络训练好之后，将之前的最后一层移除，使用隐藏层的最后一层作为输出，即使用这一层当作一段语音所提取出的特征。在注册和验证过程中，使用一段语音（utterance）进行分帧，提取filterbank特征，输入到神经网络，然后将全部帧所对应的隐藏层的最后一层求均值作为这一段语音的特征。在打分的过程中使用consine距离来判断两段语音是否来自同一个人。不过它取得的效果并不是很好，等错误率没有i-vector高。但是在加入噪声的情况下稳定性要稍微好一些。</p>
<p>这种结构的系统可以理解为使用神经网络来做一个特征提取的任务。在训练的过程中，使用softmax来对训练集中的不同说话人做一个分类。而到了注册和验证的阶段，就将这个softmax层去掉，使用倒数第二层（或者说隐藏层的最后一层）当作神经网络的输出，使用这一层当作说话人的特征，论文中也称为d-vector。然后再使用consine similarity来进行打分判别。</p>
<h2 id="d-vector改进"><a href="#d-vector改进" class="headerlink" title="d-vector改进"></a>d-vector改进</h2><p>前一篇文章虽然网络的结构比较简单，但是是第一篇完全使用神经网络用于声纹识别的文章。之后也有不少人在此基础上做了改进，下面一篇就是对d-vector对改进：<a href="https://arxiv.org/pdf/1705.03670.pdf" target="_blank" rel="noopener">Deep Speaker Feature Learning for Text-independent Speaker Verification</a>这篇文章改进了之前的结构，并且用于文本不相关的任务当中。他的结构如下：</p>
<p><img src="/upload_image/4.png" alt></p>
<p>它还是使用了40维filterbank作为输入特征，不过这里使用一帧以及它前后相邻的4帧，即一共九帧作为整个神经网络的输入（9*40）。然后经过两个卷积–池化层，然后再经过一个bottleneck层，之后再有两层time-delay层，以及一个全连接层，最后是一个5000维的softmax输出。</p>
<p>到了注册和测试阶段，同样是将最后的分类层去除，使用隐藏层的最后一层作为提取出来的特征，称为d-vector。并且将帧级别（frame level）的d-vector求均值得到utterance level的d-vector作为一段语音所代表的特征。最后文章也比较了几种分类器的效果，分别是consine、LDA和PLDA。在i-vector系统中PLDA有着最低的EER，而在d-vector中LDA则表现更加优异。（不太清楚这里是用LDA做降维后再接consine similarity还是用LDA做分类）（但是我现在还不太明白LDA是怎么进行分类的，不过找到一篇文章，分别介绍了使用LDA用于分类和降维的方法：<a href="https://towardsdatascience.com/is-lda-a-dimensionality-reduction-technique-or-a-classifier-algorithm-eeed4de9953a" target="_blank" rel="noopener">Is LDA a dimensionality reduction technique or a classifier algorithm?</a>）</p>
<h2 id="x-vector"><a href="#x-vector" class="headerlink" title="x-vector"></a>x-vector</h2><p>在18年David Snyder也就是kaldi的作者之一提出了<a href="http://www.danielpovey.com/files/2018_icassp_xvectors.pdf" target="_blank" rel="noopener">x-vector: Robust DNN Embedding for Speaker Recognition</a>，也是对于前面网络的改进，在训练的数据量较大时，可以有较低的EER。它的网络结构如下表：</p>
<p><img src="/upload_image/5.png" alt></p>
<p>看了下kaldi中的代码，感觉这里和之前的time delay有点不同。首先输入是24维的filterbank特征，使用一帧以及前后2两帧，一共5帧一个120维的一维向量作为输入，输出长度为512。如果当前时刻为t，则第二层的输入为t-2、t和t+2时刻的第一层的输入。第三层同理，使用了第二层的t-3、t和t+3时刻作为输入。第四第五就是普通的全连接层。然后到了一个stats pooling，kaldi中的注释说到：Layer after this are segment level，并且segment size是[0,max_chunk_size]，在脚本中这个max_chunk_size的大小为10000，这里就是表格中的T。这一层做的是什么呢，就是求一下之前输出的统计值，我看在脚本中是mean+stddev，也就是均值加上标准差。之后后面就是两个全连接层。最后接上一个softmax分类。</p>
<p>在网络训练好之后，把segment7和softmax层都去掉，使用segment6作为提取出来的特征，成为x-vector，然后再使用LDA降维和PLDA打分。在kaldi中，x-vector的脚本还做了其他很多操作，包括使用噪声对数据进行增强，去除时间过短的utt，然后还需要去除utt较少的speaker等。</p>
<h1 id="End-to-End"><a href="#End-to-End" class="headerlink" title="End to End"></a>End to End</h1><p>接下来就是end to end的结构，和之前的feature learning的结构相比，end to end不需要再把训练好的网络再去掉最后的那么一两层，直接输入两段语音就可以判断这语音是否来自同一个人了。end to end的最大的特点就是在训练的时候需要挑选三段语音：首先需要确定一个anchor，即目标语音；然后还需要选来自同一个说话人的正样本，和来自不同说话人的负样本。训练时候的目标就是希望来自同一个人的语音（positive pair）的embedding要极可能的相似，而来自不同人的语音（negative pair）则要尽可能的不同。在训练完成之后，就可以直接输入两段语音然后判断他们是否来自同一个人了。</p>
<h2 id="Network-in-Network"><a href="#Network-in-Network" class="headerlink" title="Network in Network"></a>Network in Network</h2><p>同样是David Snyder再16年发表的一篇文章：<a href="http://www.danielpovey.com/files/2016_slt_xvector.pdf" target="_blank" rel="noopener">Deep Neural Network-Based Speaker Embeddings for End-to-End Speaker Verification</a>，它使用了time delay Network in Network的网络结构，系统的结构如下：</p>
<p><img src="/upload_image/6.png" alt></p>
<p>首先网络的输入是MFCC特征，每一帧提取20维的MFCC特征，然后取前后各4帧一共9帧共180维的向量作为输入。然后再输入到深度神经网络当中去，它的网络的具体结构如下：<em>(这是另外一篇文章中比较feature learning和E2E两种的模型的所画的图，那篇论文图更加直观一些：<a href="https://arxiv.org/pdf/1706.07859.pdf" target="_blank" rel="noopener">Deep Speaker Verification: Do We Need End-to-End</a>）</em> </p>
<p><img src="/upload_image/7.png" alt></p>
<p>这篇文章使用40维的filterbank特征，选用当前帧以及前后各一帧，一共3帧共120维的向量作为输入。然后是time delay层，取[t-2,t+1]时刻共四个时刻600维向量作为输入经过一个1000维全连接层和500维全连接层，输出到下一个NIN中。一共有3个time delayNIN，这里最后一个time delay NIN再接一个150维的全连接层，然后再求统计值（均值和标准差）这里的方式应该和x-vector是类似的，都是求一段语音前面的再进行一个statistics pooling，最后再有一个NIN，这里就没有time delay了，再加上一个150维的全连接层。</p>
<p>他这里的loss设计的也挺复杂的，我也还是不是特别地理解，它的公式如下：<br><img src="/upload_image/8.png" alt></p>
<h2 id="Triplet-Loss"><a href="#Triplet-Loss" class="headerlink" title="Triplet Loss"></a>Triplet Loss</h2><p>自从triplet loss在人脸识别中取得成功之后，也很多人在声纹识别中也用了triplet loss。这里就选一篇来介绍下：<a href="https://www.isca-speech.org/archive/Interspeech_2017/pdfs/1608.PDF" target="_blank" rel="noopener">End-to-End Text-Independent Speaker Verification with Triplet Loss on Short Utterance</a>。首先triplet loss的公式如下：</p>
<p>$$L=\sum_{i}[||f(x_i^a)-f(x_i^p)||_2^2-||f(x_i^a)-f(x_i^n)||_2^2+\alpha]$$</p>
<p>其中上标a代表anchor，上标p代表postive，上标n代表negative，$\alpha$是一个经验值。Triplet loss的思想很简单，就是希望positive pair的欧式距离要尽可能的小，而negative pair的欧式距离则要尽可能的大。</p>
<p>对于使用triplet loss的网络来说，triplet的选取非常重要。首先，我们不可能选取全部可能的triplet，因为这样做需要的计算量非常的大。因此选取出更加有效的triplet进行训练既会提高训练的效果也会提高训练的速度。这篇文章中的triplet选取的方式如下：首先一次选出60个说话人，然后每个人随机选择40段语音，这样一个epoch一共就有60*40*39/2=46800个triplet。然后通过选取满足当下面公式alpha=0.2时的triplet拿去训练。</p>
<p>这篇文章的选用的网络结构是Inception-resnet-v1，关于这个网络的介绍网上已经有非常多了，我这里也就不做详细的介绍了。这篇文章使用了语谱图作为神经网络的输入，相当于就是一个图像识别的问题了。</p>
<h2 id="Deep-Speaker"><a href="#Deep-Speaker" class="headerlink" title="Deep Speaker"></a>Deep Speaker</h2><p>基于triplet loss的文章还有很多，更多的就是选用不同的网络结构，如百度的<a href="https://arxiv.org/pdf/1705.02304.pdf" target="_blank" rel="noopener">Deep Speaker: an End-to-End Neural Speaker Embedding System</a>,他就对比了使用ResNet和GRU的效果。之后的改进方向也可是选用更加更深层的神经网络，或者是更合理的结构。可以看到随着深度学习技术的发展，声纹识别中也在不断的应用最新的技术</p>
<h1 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h1><p>两者的区别大致如下：feature learning的思路就是使用神经网络来提取特征，它在训练的时候和验证的时候网络的结构会有所不同。在训练的时候，最后一般都使用softmax为训练集做分类。而到了验证的时候，就需要把softmax层去掉，使用倒数第二层或第三层作为提取出来的特征，然后在使用consine距离或者plda模型来进行打分判别。而end to end的思路就是去训练神经网络，使其能直接判断两段语音的相似度。<a href="https://arxiv.org/pdf/1706.07859.pdf" target="_blank" rel="noopener">Deep Speaker Verification: Do We Need End-to-End</a>这篇文章也列举来这两种结构的不同之处：</p>
<ul>
<li>不同的模型结构：end to end包括了speaker embedding(front-end)和scoring(back-end)，这两个被联合起来去训练成一个完整网络；feature learing就只包括embedding这一步。</li>
<li>不同的训练目标：end to end的训练目标是判别一对语音使来自同一个人还是不同的人；feature learning是判别在训练集中的说话人。</li>
<li>不同的训练方法：end to end是使用一对对的语音进行训练，语音对选取的好坏就会很大程度影响训练的效果；feature learning是一种one-hot式的训练方式，相比于end to end来说更容易去训练。</li>
<li>不同的泛化能力：end to end训练好之后只能用在声纹识别的任务当中去；feature learning还可以在其他的语音任务中去使用。</li>
</ul>
<h1 id="为什么i-vector依然坚挺"><a href="#为什么i-vector依然坚挺" class="headerlink" title="为什么i-vector依然坚挺"></a>为什么i-vector依然坚挺</h1><p>之前在知乎上看到这样的一个问题：<a href="https://www.zhihu.com/question/67471632" target="_blank" rel="noopener">为什么在说话人识别技术中，i-vector+plda面对神经网络依然坚挺</a>在目前最前沿的说话人识别系统中，仍然有不少是基于i-vector+PLDA的，在2017年ICASSP和Interspeech中，基于i-vector的说话人识别论文数量和基于神经网络的论文数依然可以抗衡。在神经网络席卷了机器学习众多领域的今天，为什么i-vector依然能够坚挺地存在呢？它有什么优点是神经网络所没有的？最高票的答主做了很好的回答，这里概括一下：</p>
<blockquote>
<p>为什么在语音识别中DNN的应用会带来如此明显的提升，在说话人识别任务中却给人一种挣扎的感觉？这和任务属性是直接相关的，语音识别中，输出的是senone，不存在集外的概念。任何一句话里面的音素都能找到它对应的节点。但是说话人识别不一样，我们不可能要求测试的人在训练过程中出现，更不可能直接训练一个所有人的分类器。因此我们需要找到一个隐变量空间，每个人都是空间上的一个点，可以用这个空间的一组基来表示。i-vector就是找到了这样的一个隐变量空间。</p>
</blockquote>
]]></content>
      <categories>
        <category>声纹识别</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>声纹识别</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Kaldi中的声纹识别</title>
    <url>/posts/364e185b/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>前段时间一直到在使用kaldi来做声纹识别，算是可以把整个ivector的例程可以跑下来，也可以根据例程来改写脚本，使用自己的数据来训练和测试。接下来可能要去做其他的项目了，所以要趁着还记得的时候赶紧写个总结，也算是对之前的工作也算是归纳一下。<br><a id="more"></a></p>
<h2 id="kaldi的安装"><a href="#kaldi的安装" class="headerlink" title="kaldi的安装"></a>kaldi的安装</h2><p>kaldi在Linux下的安装总的来说还是比较简单的，首先是先进入tools中运行extras/check_dependenices.sh看下还有哪些依赖项没有安装，然后就可以按照他的提示来安装依赖项目。安装完依赖项之后就分别进入tools目录和src目录下执行命令make -j8，其中8时cpu可以同时运行的线程数量。这个过程还是需要一定时间的。在make完之后就可以运行一个小的例程来看下有没有成功地安装kaldi，我们进入到egs/yesno/s5目录下然后运行run.sh脚本，这是一个判断语音中说的是yes还是no的程序，他会自动下载数据并训练和测试，最终可以有0.0%的WER，这就代表kaldi安装成功啦✌️</p>
<h2 id="运行aishell例程"><a href="#运行aishell例程" class="headerlink" title="运行aishell例程"></a>运行aishell例程</h2><p>首先我们来看下kaldi下的目录：</p>
<p><img src="/upload_image/1.png" alt></p>
<ul>
<li>egs：保存了各种例程，均使用脚本编写，以使用的数据库的名字命名。在下一级目录中以s开头的文件是语音识别，以v开头的是声纹识别，一般v1就是使用i-vector的方法来进行声纹识别。</li>
<li>src：保存了kaldi的C++代码。</li>
<li>tools：包括了kaldi依赖的库和一些实用的脚本。</li>
<li>windows：包括了在Windows下安装需要的一些工具和配置文件</li>
</ul>
<p>接下来我们就来跑一下aishell的声纹识别例程，在egs/aishell/v1中的run.sh就包括了整个声纹识别的流程，最好将run.sh中的命令复制到另外一个脚本中，一句一句地执行，这样就能及时发现错误然后修改。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">data=/<span class="built_in">export</span>/a05/xna/data</span><br><span class="line">data_url=www.openslr.org/resources/33</span><br><span class="line"></span><br><span class="line">. ./cmd.sh</span><br><span class="line">. ./path.sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -e <span class="comment"># exit on error</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span>/download_and_untar.sh <span class="variable">$data</span> <span class="variable">$data_url</span> data_aishell</span><br><span class="line"><span class="built_in">local</span>/download_and_untar.sh <span class="variable">$data</span> <span class="variable">$data_url</span> resource_aishell</span><br><span class="line"></span><br><span class="line"><span class="comment"># Data Preparation</span></span><br><span class="line"><span class="built_in">local</span>/aishell_data_prep.sh <span class="variable">$data</span>/data_aishell/wav <span class="variable">$data</span>/data_aishell/transcript</span><br></pre></td></tr></table></figure>
<p>首先是数据准备阶段，如果没有下载数据，脚本也可以自动下载和解压；如果下载好了就要把data的路径改成自己存放数据的路径。之后的cmd.sh和path.sh分别是设置执行命令的方式和kaldi的路径。如果我们是在自己的电脑上运行，就需要进入到cmd.sh中，把queue.pl修改成run.pl。path.sh就是设置和kaldi相关的路径，如果是例程的话就不用修改了。配置好之后就开始下载和解压数据。</p>
<p>之后就是最关键的部分了，准备一些下面环节需要的文档，使用aishell_data_prep.sh这个脚本来生成。声纹识别需要用到的分别是utt2spk spk2utt wav.scp这三个文件。其中utt指的是utterance代表一个音频文件的文件名，spk代表speaker是说话人的ID，这里在下一节做详细的介绍。如果是做语音识别，还需要text文件，这里就不做介绍了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Now make MFCC  features.</span></span><br><span class="line"><span class="comment"># mfccdir should be some place with a largish disk where you</span></span><br><span class="line"><span class="comment"># want to store MFCC features.</span></span><br><span class="line">mfccdir=mfcc</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> train <span class="built_in">test</span>; <span class="keyword">do</span></span><br><span class="line">  steps/make_mfcc.sh --cmd <span class="string">"<span class="variable">$train_cmd</span>"</span> --nj 10 data/<span class="variable">$x</span> exp/make_mfcc/<span class="variable">$x</span> <span class="variable">$mfccdir</span></span><br><span class="line">  sid/compute_vad_decision.sh --nj 10 --cmd <span class="string">"<span class="variable">$train_cmd</span>"</span> data/<span class="variable">$x</span> exp/make_mfcc/<span class="variable">$x</span> <span class="variable">$mfccdir</span></span><br><span class="line">  utils/fix_data_dir.sh data/<span class="variable">$x</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>在准备好数据之后就要开始提取mfcc特征了（make_mfcc的过程中也包括了分帧加窗），进行端点检测（VAD），以及检查文件符不符合要求对文件进行排序（其实我也没有看太懂fix_data_dir.sh这个脚本到底做了什么😑)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># train diag ubm</span></span><br><span class="line">sid/train_diag_ubm.sh --nj 10 --cmd <span class="string">"<span class="variable">$train_cmd</span>"</span> --num-threads 16 \</span><br><span class="line">  data/train 1024 exp/diag_ubm_1024</span><br><span class="line"></span><br><span class="line"><span class="comment">#train full ubm</span></span><br><span class="line">sid/train_full_ubm.sh --nj 10 --cmd <span class="string">"<span class="variable">$train_cmd</span>"</span> data/train \</span><br><span class="line">  exp/diag_ubm_1024 exp/full_ubm_1024</span><br><span class="line"></span><br><span class="line"><span class="comment">#train ivector</span></span><br><span class="line">sid/train_ivector_extractor.sh --cmd <span class="string">"<span class="variable">$train_cmd</span> --mem 10G"</span> \</span><br><span class="line">  --num-iters 5 exp/full_ubm_1024/final.ubm data/train \</span><br><span class="line">  exp/extractor_1024</span><br></pre></td></tr></table></figure>
<p>再接下来就是训练UBM和ivector extractor了，这里需要注意的是训练ivector extractor的脚本会默认同时执行程序非常多，会占用很高的内存导致内存溢出。我们需要进入train_ivector_extractor.sh中修改一下。它默认同时执行的程序数量为nj*num_thread*num_processes,在16G内存下我把这三个参数都改为2才能跑通。这里也还有两个超参数可以修改，分别是UBM的维数和ivector的维数，UBM的维数就直接在run.sh中修改就行，train_diag_ubm.sh中data/train后面那个参数就是UBM的维数，默认为1024。要修改ivector的维数就同样需要进到train_ivector_extractor.sh中修改ivector_dim，默认为400。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#extract ivector</span></span><br><span class="line">sid/extract_ivectors.sh --cmd <span class="string">"<span class="variable">$train_cmd</span>"</span> --nj 10 \</span><br><span class="line">  exp/extractor_1024 data/train exp/ivector_train_1024</span><br><span class="line"></span><br><span class="line"><span class="comment">#train plda</span></span><br><span class="line"><span class="variable">$train_cmd</span> exp/ivector_train_1024/<span class="built_in">log</span>/plda.log \</span><br><span class="line">  ivector-compute-plda ark:data/train/spk2utt \</span><br><span class="line">  <span class="string">'ark:ivector-normalize-length scp:exp/ivector_train_1024/ivector.scp  ark:- |'</span> \</span><br><span class="line">  exp/ivector_train_1024/plda</span><br></pre></td></tr></table></figure>
<p>训练完ivector之后就要开始提取训练集的ivector了，然后用训练集的ivector来训练plda模型用于打分。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># split the test to enroll and eval</span></span><br><span class="line">mkdir -p data/<span class="built_in">test</span>/enroll data/<span class="built_in">test</span>/<span class="built_in">eval</span></span><br><span class="line">cp data/<span class="built_in">test</span>/&#123;spk2utt,feats.scp,vad.scp&#125; data/<span class="built_in">test</span>/enroll</span><br><span class="line">cp data/<span class="built_in">test</span>/&#123;spk2utt,feats.scp,vad.scp&#125; data/<span class="built_in">test</span>/<span class="built_in">eval</span></span><br><span class="line"><span class="built_in">local</span>/split_data_enroll_eval.py data/<span class="built_in">test</span>/utt2spk  data/<span class="built_in">test</span>/enroll/utt2spk  data/<span class="built_in">test</span>/<span class="built_in">eval</span>/utt2spk</span><br><span class="line">trials=data/<span class="built_in">test</span>/aishell_speaker_ver.lst</span><br><span class="line"><span class="built_in">local</span>/produce_trials.py data/<span class="built_in">test</span>/<span class="built_in">eval</span>/utt2spk <span class="variable">$trials</span></span><br><span class="line">utils/fix_data_dir.sh data/<span class="built_in">test</span>/enroll</span><br><span class="line">utils/fix_data_dir.sh data/<span class="built_in">test</span>/<span class="built_in">eval</span></span><br></pre></td></tr></table></figure>
<p>之后就要将测试集分为注册集和验证集，这一步主要通过loacl/split_data_enroll_eval.py这个脚本来完成，我们先来看一下这个脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># split_data_enroll_eval.py</span></span><br><span class="line"><span class="keyword">import</span> sys,random</span><br><span class="line"></span><br><span class="line">dictutt = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> open(sys.argv[<span class="number">1</span>]):</span><br><span class="line">  line = line.rstrip(<span class="string">'\r\t\n '</span>)</span><br><span class="line">  utt, spk = line.split(<span class="string">' '</span>)</span><br><span class="line">  <span class="keyword">if</span> spk <span class="keyword">not</span> <span class="keyword">in</span> dictutt:</span><br><span class="line">    dictutt[spk] = []</span><br><span class="line">  dictutt[spk].append(utt)</span><br><span class="line"></span><br><span class="line">fenroll = open(sys.argv[<span class="number">2</span>], <span class="string">'w'</span>)</span><br><span class="line">feval = open(sys.argv[<span class="number">3</span>], <span class="string">'w'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> dictutt:</span><br><span class="line">  utts = dictutt[key]</span><br><span class="line">  random.shuffle(utts)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(utts)):</span><br><span class="line">    line = utts[i] + <span class="string">' '</span> + key</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">3</span>):</span><br><span class="line">      fenroll.write(line + <span class="string">'\n'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      feval.write(line + <span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">fenroll.close()</span><br><span class="line">feval.close()</span><br></pre></td></tr></table></figure>
<p>这个脚本首先先将每个spk和与其对应的utt存入dictutt中，然后再将spk的utt顺序随机打乱，重新分配到enroll（注册集）和eval（评估集）中。可以看到在程序的倒数第六行中，if(i&lt;3):就将utt写入enroll中，否则就写入eval中。所以我们可以通过改这个值来改变注册集和评估集中的语音数。</p>
<p>在重新生成完utt2spk之后，就要生成trials了。trials通过loacl/product_trials.py来生成。trials是指需要进行打分的注册说话人和不同的语音的一个列表，它的格式为(举个例子🌰）：</p>
<table>
<thead>
<tr>
<th>uttID</th>
<th>spkID</th>
<th>target/nontarget</th>
</tr>
</thead>
<tbody>
<tr>
<td>spkA-utt1</td>
<td>spkA</td>
<td>target</td>
</tr>
<tr>
<td>spkA-utt2</td>
<td>spkB</td>
<td>nontarget</td>
</tr>
<tr>
<td>spkB-utt1</td>
<td>spkA</td>
<td>nontarget</td>
</tr>
<tr>
<td>spkB-utt1</td>
<td>spkB</td>
<td>target</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#extract enroll ivector</span></span><br><span class="line">sid/extract_ivectors.sh --cmd <span class="string">"<span class="variable">$train_cmd</span>"</span> --nj 10 \</span><br><span class="line">  exp/extractor_1024 data/<span class="built_in">test</span>/enroll  exp/ivector_enroll_1024</span><br><span class="line"><span class="comment">#extract eval ivector</span></span><br><span class="line">sid/extract_ivectors.sh --cmd <span class="string">"<span class="variable">$train_cmd</span>"</span> --nj 10 \</span><br><span class="line">  exp/extractor_1024 data/<span class="built_in">test</span>/<span class="built_in">eval</span>  exp/ivector_eval_1024</span><br><span class="line"></span><br><span class="line"><span class="comment">#compute plda score</span></span><br><span class="line"><span class="variable">$train_cmd</span> exp/ivector_eval_1024/<span class="built_in">log</span>/plda_score.log \</span><br><span class="line">  ivector-plda-scoring --num-utts=ark:exp/ivector_enroll_1024/num_utts.ark \</span><br><span class="line">  exp/ivector_train_1024/plda \</span><br><span class="line">  ark:exp/ivector_enroll_1024/spk_ivector.ark \</span><br><span class="line">  <span class="string">"ark:ivector-normalize-length scp:exp/ivector_eval_1024/ivector.scp ark:- |"</span> \</span><br><span class="line">  <span class="string">"cat '<span class="variable">$trials</span>' | awk '&#123;print \\\$2, \\\$1&#125;' |"</span> exp/trials_out</span><br><span class="line"></span><br><span class="line"><span class="comment">#compute eer</span></span><br><span class="line">awk <span class="string">'&#123;print $3&#125;'</span> exp/trials_out | paste - <span class="variable">$trials</span> | awk <span class="string">'&#123;print $1, $4&#125;'</span> | compute-eer -</span><br></pre></td></tr></table></figure>
<p>在将测试集分成注册集和评估集之后，就开始分别提取注册集和评估集的ivector，然后按照生成的trials打分，最终打分结果输出在trials_out中,最终跑出来的结果为eer为0.183%。</p>
<h2 id="使用TIMIT数据库进行声纹识别"><a href="#使用TIMIT数据库进行声纹识别" class="headerlink" title="使用TIMIT数据库进行声纹识别"></a>使用TIMIT数据库进行声纹识别</h2><p>在了解了kaldi中整个声纹识别的流程后，我们就可以AISHELL的例程来改写使用自己数据的声纹识别系统，这里我使用TIMIT数据库。</p>
<p>我们首先看下AISHELL和TIMIT数据库中的数据划分。AISHELL中一共有400人，默认分为train、dev和test集。其中train里面有340人；dev里面有40人；test里面有20人。在例程中，使用train作为训练集，test作为测试集，并没有使用dev。AISHELL里每个人大概有300多段语音，每段语音是一句话，每段语音大概在2~6s。在TIMIT数据库中一共有630人，分为train和test。训练集中有462人，测试集中有168人。每个人分别有10段语音，每段语音大概在2~4s。这里就直接使用TIMIT的原本的分配方式，用462人作为训练集，168人作为测试集。</p>
<p>不过使用TIMIT数据库还有一个问题就是，TIMIT数据库中文件存放以及命名的方式和AISHELL不太一样。TIMIT数据库下文件存放的结构是，/TRAIN/DR<em>/SPEARKER_ID/UTTERANCE_ID.wav，train代表是训练集或者测试集，DR\</em>（1～8）代表了说话人的方言类型，然后是说话人的ID文件夹，文件夹下存放了10段语音。TIMIT数据库中不同的人会说同一段话，说的话的内容是一样的话文件名就是一样的，我不知道如果有相同的文件名会不会引发错误，稳妥起见还是把每个文件都重新命名了。我写了个程序，将文件都重新命名为说话人的ID加上音频的序号，并且将其重新保存在/TRAIN/SPEAKER_ID这样的目录下，这样就在下面的程序就可以不用修改太多。</p>
<p>在了解完两个数据库的区别和整个声纹识别的流程之后，我们就可以开始改写我们的程序了。其实整个过程中需要改的地方并不多，主要就是在准备数据阶段和生成trials的过程需要修改一下。首先是数据准备阶段，我们就可以根据哈aishell_data_prepare.sh这个脚本来改写自己的timit_data_prepare.sh了。数据准备阶段就要生成utt2spk spk2utt和wav.scp这三个文件。这三个文件的格式如下：</p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>格式</th>
</tr>
</thead>
<tbody>
<tr>
<td>utt2spk</td>
<td>[音频文件名] [说话人ID]</td>
</tr>
<tr>
<td>spk2utt</td>
<td>[说话人名] [音频文件名] [音频文件名] [音频文件名]</td>
</tr>
<tr>
<td>wav.scp</td>
<td>[音频文件名] [音频文件的具体路径]</td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">. ./path.sh || <span class="built_in">exit</span> 1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> != 2 ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Usage: <span class="variable">$0</span> &lt;audio-path&gt; &lt;text-path&gt;"</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">" <span class="variable">$0</span> /export/a05/xna/data/data_aishell/wav /export/a05/xna/data/data_aishell/transcript"</span></span><br><span class="line">  <span class="built_in">exit</span> 1;</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">aishell_audio_dir=<span class="variable">$1</span></span><br><span class="line">aishell_text_dir=<span class="variable">$2</span></span><br><span class="line"></span><br><span class="line">train_dir=data/<span class="built_in">local</span>/train</span><br><span class="line">dev_dir=data/<span class="built_in">local</span>/dev</span><br><span class="line">test_dir=data/<span class="built_in">local</span>/<span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">mkdir -p <span class="variable">$train_dir</span></span><br><span class="line">mkdir -p <span class="variable">$dev_dir</span></span><br><span class="line">mkdir -p <span class="variable">$test_dir</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># data directory check</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="variable">$aishell_audio_dir</span> ] || [ ! -d <span class="variable">$aishell_text_dir</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Error: <span class="variable">$0</span> requires two directory arguments"</span></span><br><span class="line">  <span class="built_in">exit</span> 1;</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># find wav audio file for train, dev and test resp.</span></span><br><span class="line">find <span class="variable">$aishell_audio_dir</span> -iname <span class="string">"*.wav"</span> | grep -i <span class="string">"wav/train"</span> &gt; <span class="variable">$train_dir</span>/wav.flist || <span class="built_in">exit</span> 1;</span><br><span class="line">find <span class="variable">$aishell_audio_dir</span> -iname <span class="string">"*.wav"</span> | grep -i <span class="string">"wav/dev"</span> &gt; <span class="variable">$dev_dir</span>/wav.flist || <span class="built_in">exit</span> 1;</span><br><span class="line">find <span class="variable">$aishell_audio_dir</span> -iname <span class="string">"*.wav"</span> | grep -i <span class="string">"wav/test"</span> &gt; <span class="variable">$test_dir</span>/wav.flist || <span class="built_in">exit</span> 1;</span><br></pre></td></tr></table></figure>
<p>前面首先是检查路径和创建用来存放文件的路径，由于在TIMIT中没有dev集，所以要把带有dev的都删掉。接下来脚本查找目录下的所有wav文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">n=`cat <span class="variable">$train_dir</span>/wav.flist <span class="variable">$dev_dir</span>/wav.flist <span class="variable">$test_dir</span>/wav.flist | wc -l`</span><br><span class="line">[ <span class="variable">$n</span> -ne 141925 ] &amp;&amp; \</span><br><span class="line">  <span class="built_in">echo</span> Warning: expected 141925 data data files, found <span class="variable">$n</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Transcriptions preparation</span></span><br><span class="line"><span class="keyword">for</span> dir <span class="keyword">in</span> <span class="variable">$train_dir</span> <span class="variable">$test_dir</span>; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> Preparing <span class="variable">$dir</span> transcriptions</span><br><span class="line">  sed -e <span class="string">'s/\.wav//'</span> <span class="variable">$dir</span>/wav.flist | awk -F <span class="string">'/'</span> <span class="string">'&#123;print $NF&#125;'</span> &gt; <span class="variable">$dir</span>/utt.list</span><br><span class="line">  sed -e <span class="string">'s/\.wav//'</span> <span class="variable">$dir</span>/wav.flist | awk -F <span class="string">'/'</span> <span class="string">'&#123;i=NF-1;printf("%s %s\n",$NF,$i)&#125;'</span> &gt; <span class="variable">$dir</span>/utt2spk_all</span><br><span class="line">  paste -d<span class="string">' '</span> <span class="variable">$dir</span>/utt.list <span class="variable">$dir</span>/wav.flist &gt; <span class="variable">$dir</span>/wav.scp_all</span><br><span class="line">  utils/filter_scp.pl -f 1 <span class="variable">$dir</span>/utt.list <span class="variable">$aishell_text_dir</span>/*.txt &gt; <span class="variable">$dir</span>/transcripts.txt</span><br><span class="line">  awk <span class="string">'&#123;print $1&#125;'</span> <span class="variable">$dir</span>/transcripts.txt | sort -u &gt; <span class="variable">$dir</span>/utt.list</span><br><span class="line">  utils/filter_scp.pl -f 1 <span class="variable">$dir</span>/utt.list <span class="variable">$dir</span>/utt2spk_all | sort -u &gt; <span class="variable">$dir</span>/utt2spk</span><br><span class="line">  utils/filter_scp.pl -f 1 <span class="variable">$dir</span>/utt.list <span class="variable">$dir</span>/wav.scp_all | sort -u &gt; <span class="variable">$dir</span>/wav.scp</span><br><span class="line">  sort -u <span class="variable">$dir</span>/transcripts.txt &gt; <span class="variable">$dir</span>/text</span><br><span class="line">  utils/utt2spk_to_spk2utt.pl <span class="variable">$dir</span>/utt2spk &gt; <span class="variable">$dir</span>/spk2utt</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">mkdir -p data/train data/<span class="built_in">test</span></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> spk2utt utt2spk wav.scp text; <span class="keyword">do</span></span><br><span class="line">  cp <span class="variable">$train_dir</span>/<span class="variable">$f</span> data/train/<span class="variable">$f</span> || <span class="built_in">exit</span> 1;</span><br><span class="line">  cp <span class="variable">$test_dir</span>/<span class="variable">$f</span> data/<span class="built_in">test</span>/<span class="variable">$f</span> || <span class="built_in">exit</span> 1;</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$0</span>: AISHELL data preparation succeeded"</span></span><br><span class="line"><span class="built_in">exit</span> 0;</span><br></pre></td></tr></table></figure>
<p>接下来就检查找到的wav文件加起来有没有141924个，然后就开始做wav.scp、utt2spk和spk2utt以及用于语音识别的transcripts.txt，这里我们就要找到脚本中和transcripts.txt相关的，然后删掉就可以了。</p>
<p>再做完准备数据的阶段之后，我们就可以开始按照上面的流程来进行声纹识别了。还需要注意的一点是trials，如果一个人只有两三段语音的话，就需要修改分配enroll集和eval集的比例。不过由于TIMIT数据库每个人有10段语音，所以不用修改也是可以的。这里就用3段语音去注册，然后剩下的7段语音用于验证。</p>
<p>最终跑出来的等错误率在4.5%左右，虽然是一个还可以接受的结果，但是和AISHELL的0.18%的等错误率相比还是差了很多的。分析一下原因：首先是用于训练的语音较少，虽然人数有462人，但是每个人只有10段语音，和AISHELL中340人用于训练，每个人300多段语音相比差了很多。同样的，TIMIT中测试集中一共有168人，相比于AISHELL中测试集只有40人多了很多。而且，AISHELL默认的训练的UBM阶数和ivector的维度都非常高，所以这两点可能导致了等错误率比较高。如果想进一步降低等错误率可以尝试降低训练的UBM和ivector的维度。我把UBM和ivector的维度都降低后，等错误率最终可以达到1.53%。</p>
<h2 id="kaldi中声纹识别的流程"><a href="#kaldi中声纹识别的流程" class="headerlink" title="kaldi中声纹识别的流程"></a>kaldi中声纹识别的流程</h2><p>总结一下，kaldi中声纹的识别（ivector）的流程图如下：</p>
<p><img src="/upload_image/2.png" alt></p>
<p>首先，将数据集分为训练集和测试集。然后对先对训练集做处理，先提取训练集的mfcc特征，然后训练UBM和ivector extractor，接着提取训练集的ivector，并使用训练集的ivector去训练plda模型。之后就开始对测试集进行处理，先把测试集分为注册集和验证集，分别提取mfcc然后在提取ivector，在用plda进行打分。这就是整个kaldi中ivector声纹识别的流程了。</p>
]]></content>
      <categories>
        <category>声纹识别</category>
        <category>kaldi</category>
      </categories>
      <tags>
        <tag>声纹识别</tag>
        <tag>kaldi</tag>
        <tag>ivector</tag>
      </tags>
  </entry>
</search>
